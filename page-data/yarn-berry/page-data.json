{"componentChunkName":"component---src-templates-blog-post-js","path":"/yarn-berry/","result":{"data":{"site":{"siteMetadata":{"title":"read0more's blog"}},"markdownRemark":{"id":"1740aa06-b19f-5093-bf77-6abd30ec6631","excerpt":"Yarn Berry? yarn V2의 명칭이며 현재 V1은 1.22.19를 마지막으로 관리가 중단된 상태이다.\nberry는 npm의 각종 문제점을 개선해준다. 토스 기술 블로그에 굉장히 잘 정리되어 있는데, 본 글은 링크의 글을 보고 알게 된 것을 정리한 글이다. NPM…","html":"<h2>Yarn Berry?</h2>\n<p>yarn V2의 명칭이며 현재 V1은 1.22.19를 마지막으로 관리가 중단된 상태이다.\nberry는 npm의 각종 문제점을 개선해준다. <a href=\"https://toss.tech/article/node-modules-and-yarn-berry\">토스 기술 블로그</a>에 굉장히 잘 정리되어 있는데, 본 글은 링크의 글을 보고 알게 된 것을 정리한 글이다.</p>\n<h2>NPM의 문제점</h2>\n<ol>\n<li>비효율적인 의존성 검색</li>\n</ol>\n<ul>\n<li>파일 시스템을 이용하여 의존성을 관리하는데, 패키지를 찾기 위해 계속 상위 디렉토리의 node_modules 디렉토리를 탐색한다. 따라서 패키지를 늦게 찾을 수록 readdir, stat과 같은 느린 I/O 호출이 반복되고 심지어 경우에 따라서는 실패하기도 한다.</li>\n</ul>\n<ol start=\"2\">\n<li>환경에 따라 달라지는 동작</li>\n</ol>\n<ul>\n<li>1에서 언급한 대로 NPM은 상위 디렉토리의 node_modules를 찾을 때 까지 검색한다. 이 특성 때문에 어떤 의존성을 찾게 될지는 해당 패키지의 상위 디렉토리 환경에 따라 달라지기 때문에 의존성을 불러오지 못하거나 다른 버전을 불러오게 될 수 있다.</li>\n</ul>\n<ol start=\"3\">\n<li>비효율적인 설치</li>\n</ol>\n<ul>\n<li>node_modules 디렉토리 구조는 매우 큰 공간을 차지한다. 또한 많은 I/O 호출이 필요해 진다. 이런 깊은 트리 구조에서 잘 설치됐는지 검증하려면 많은 수의 I/O 호출이 필요하기 때문에, Yarn v1과 NPM은 각 패키지의 내용이 올바른지 까지는 확인하지 않는다.</li>\n</ul>\n<ol start=\"4\">\n<li>유령 의존성</li>\n</ol>\n<ul>\n<li>Yarn v1과 NPM은 중복 설치되는 패키지를 줄이기 위해 호이스팅 기법을 사용한다. 여기까지만 들었을때는 그냥 좋다고 생각할 수도 있겠지만</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/my-blog/static/30cb503360fcc1ca5e0cd63c2160d7de/081d5/pd.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.5945945945946%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB2ElEQVR42m2STYvTUBSG81PEvX/EvRt3ggjOwpUuBRfOSh3QhQwKgjAoA+IXohudxYAOVgc7A5V0sJM2bZOmzcfNR9vcJDePJG21iC9cLufch3POvffVAIoix45crNjHmUW4SQBlSbm2KiWzCNu3caaC8VQwCBzCioWaUUqhqTynwicfn9J5cIXhww0i/WABqeIPXCpFFYWdJqf3L9O+dwnn9Vadq85WjTWWSg4/YO7cZvR8E9lrrdJkWUZRFKhC1bF0elgv7tLfvUNy8GbZcK1gq9Fn7+URbpAzilMskRLNJH3TJE1ThBBkmVyWL5EZTKZgJTBKVDVefdWVtPfbOtvXvtLXPURk405sojDEMAx836+hyJ/Tbg4YWwFGcMSxtYcvRngTt2aiKMZ1PaSUaO3oC9+CV4i5S3O/x89Ds76mZVnMpvO64Oe3HW5deMen3RaPvYvc6J7lV9xgPPAZOdUAAuO0QygCtCeDq9wcnOPQ2OfRxg+ebX7H9wJ0XcfzPBYuUGSyqPe8lEg1R6mifjOZ5diTkOE4YDgW1acsLFGBJ34DIzhmXSvL/E2s74vAD0KMronnCzRVLh7UTk+43j3D1vA8WS5rtvzHi/9btUOSGLPXI44jfgNdeZ8Jc2u2XQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Phantom Dependency\"\n        title=\"\"\n        src=\"/my-blog/static/30cb503360fcc1ca5e0cd63c2160d7de/fcda8/pd.png\"\n        srcset=\"/my-blog/static/30cb503360fcc1ca5e0cd63c2160d7de/12f09/pd.png 148w,\n/my-blog/static/30cb503360fcc1ca5e0cd63c2160d7de/e4a3f/pd.png 295w,\n/my-blog/static/30cb503360fcc1ca5e0cd63c2160d7de/fcda8/pd.png 590w,\n/my-blog/static/30cb503360fcc1ca5e0cd63c2160d7de/efc66/pd.png 885w,\n/my-blog/static/30cb503360fcc1ca5e0cd63c2160d7de/c83ae/pd.png 1180w,\n/my-blog/static/30cb503360fcc1ca5e0cd63c2160d7de/081d5/pd.png 1264w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>상기 이미지 처럼 원래 package-1에서 가져올 수 없어야 하는 **B(1.0)**도 가져올 수 있게 되버렸다. 만약 누가 실수로라도 **B(1.0)**을 사용을 했고, 누군가가 B(1.0)패키지를 포함하는 패키지가 더 이상 사용되지 않는다고 생각해서 제거했다면 소리없이 같이 사라져 버릴 것이다.</li>\n</ul>\n<h2>Plug'n'Play(PnP)</h2>\n<ul>\n<li>위의 문제들을 해결하기 위해 Yarn Berry는 PnP 전략을 이용하여 해결한다.</li>\n</ul>\n<p>node_module를 생성하지 않고, <code>.yarn/cache</code> 디렉토리에 의존성의 정보를 zip파일로 저장하고, <code>.pnp.cjs</code>파일에 의존성을 찾을 수 있는 정보가 기록된다.\n이로 인해 문제가 되던 디스크 I/O 없이 어떤 패키지가 어떤 라이브러리에 의존하고 위치하는지를 바로 알 수 있게 되었다.</p>\n<h2>PnP적용으로 얻는 이점</h2>\n<ol>\n<li>향상된 의존성 검색 시간</li>\n</ol>\n<ul>\n<li><code>.pnp.cjs</code>파일을 통해 디스크 I/O 없이 어떤 패키지가 어떤 라이브러리에 의존하고 위치하는지를 바로 알 수 있게 되었기 때문에 빠르다</li>\n</ul>\n<ol start=\"2\">\n<li>재현성</li>\n</ol>\n<ul>\n<li><code>.pnp.cjs</code>로 관리되기 때문에 더 이상 외부 환경에 영향받지 않는다. 이로 인해 require() 또는 import문의 동작이 동일할 것임을 보장할 수 있게 되었다.</li>\n</ul>\n<ol start=\"3\">\n<li>zero-install로 인한 설치시간 단축</li>\n</ol>\n<ul>\n<li>깊은 node_modules 디렉토리를 생성하지 않아도 된다. 또한 .yarn/cache에 zip파일로 있는 압축파일을 repo에 올려 같이 관리를 하면 추가 없이 바로 실행이 가능하다. 기존 node_modules와 같이 많은 파일과 용량이 컸다면 사용할 수 없었겠지만 PnP전략으로 인해 zero-install이 가능해 졌다. 기존 방식으로는 브랜치를 바꾸고 의존성 설치를 다시하고...이런 작업이 필요가 없다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/my-blog/static/a0926f47d1d310e051ce5839073b24c8/a83dd/zi.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.48648648648649%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACHElEQVR42lWS2VbbMBCGfduNpRBiS7KsfbFjOyQQKG1Pr6C9aOhN+/6P8vdoCBy4+DyLrF/SzFQuJOjpDnb9HW7zAypfIsaIVipwIcFEC9NZTOMMHxOs85jmNWLM6JSGcwH9sHqJq05bhDRAW48ibn2EdQHaOPgQ4Sn2MGXdB4SQ4HyEOayX/8paEVTaorJKYcoJVhv4EAhtLDqlaEPuexIqpxtjKQ4h0nqI5TBHfs4Z2hhUPkYopbEaR7rJsm5QNw24EOCc46Lh4PESzGRon9H3PZY1w+KixvnFkuxiWeN88eRXUkrITkJphVa2YJwTXHDwVsKYGrvtEXbbY9xeneLL9SlutsdvKPnb7QnZSoYBabqEc5Zu1jB2oIGQGuOK4d/+M/7+PsP+/j0eHz7g8edH/Cn8+oT9/TuK9w/vKa664QpxvUMr+BtB8rmA0hxTv8CQz5DCMXI4IfvMS+wLR6jU6hp5cwPvDIm8puEMstP4Ot9hGGZYn6ijxgZYFwmlHdEwCVYLVKrfoN/cwhqNmjGqX1MovhBopYRWCrLryH9NyZUOl/oXW3KVdAHD7htSimg7hbbrILWCMga8bSkX+xXdtAy6aDui+PowRik9dV92ClV5Wowe2+0G8zxhvZ4xzRP6oadOt9pATzcQrXgapQPlJfWh1i8lYgxV+aScSGg1rogimFKijUJKWKsxTiNSzsTzEBfB5rlEhzL9Bx91UapO6c7kAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Zero Install\"\n        title=\"\"\n        src=\"/my-blog/static/a0926f47d1d310e051ce5839073b24c8/fcda8/zi.png\"\n        srcset=\"/my-blog/static/a0926f47d1d310e051ce5839073b24c8/12f09/zi.png 148w,\n/my-blog/static/a0926f47d1d310e051ce5839073b24c8/e4a3f/zi.png 295w,\n/my-blog/static/a0926f47d1d310e051ce5839073b24c8/fcda8/zi.png 590w,\n/my-blog/static/a0926f47d1d310e051ce5839073b24c8/efc66/zi.png 885w,\n/my-blog/static/a0926f47d1d310e051ce5839073b24c8/c83ae/zi.png 1180w,\n/my-blog/static/a0926f47d1d310e051ce5839073b24c8/a83dd/zi.png 1482w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n<em>yarn berry또한 .yarn/cache 디렉토리를 같이 repo에 올려 관리하고 있다.</em>\n4. 엄격한 의존성 관리</p>\n<ul>\n<li>node_modules와 같은 호이스팅을 하지 않아 유령 의존성이 일어나지 않는다.</li>\n</ul>\n<ol start=\"5\">\n<li>의존성 검증</li>\n</ol>\n<ul>\n<li>node_modules 방식에서는 올바르게 의존성이 설치되지 못해 귀찮게 node_modules 디렉토리 전체를 지우고 다시 설치하는 경우가 발생하곤 했다. 하지만 이제 <code>.yarn/cache에서</code>zip으로 관리하면서 빠진 의존성을 찾거나 변경된 부분을 찾기가 쉬워졌다.</li>\n</ul>\n<h2>PnP 적용법(TS + VSCode)</h2>\n<ol>\n<li>VSCode 익스텐션 ZipFs 설치(VSCode가 zip의존성을 읽을 수 있게 해준다)</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/my-blog/static/1db220041cd22c8624b08248b4b48699/78612/zip.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 29.72972972972973%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABdElEQVR42nWRvW7TUBiGcwtIrZo45ziOj5O4PnaPU9t1UodgpNDKkEL5mSok/qQuLIyVkKquCAk2boAbQGIuU8XCwMTYuZfQ8UE5SAxIDI/eb3r0vvpa0unQv7VEPz9BVXu4Tpu8KKjrmiRJiOOY6XRKWZZkeU45rSjKCWE4whiDUgopJa7r2mz1bx+Sfbpg8fkn8cdzNrKaelbRLA/YMobtLOfO3j7V7Ca7Zc79Rcn+vMCY1Ep7vR6O4yCEsNKW9/KMZ19+cfb1Byfnlzx8c0rku2wnm6TxJnroM9YjtpIYHYVM0hG5CSmKAq21ZbVklbZhe/6At98u+X51zcXVNR/ev8ObNJhHrwmqJePDY6J7r1CRIYk1wTDEVwOCILAMBn/u1XTbUHYdhovHZMen7Nx9wiBQ6PmS8cELollD2hxhmqekO7vEOrLTpBA2/8U2XFnFxjqdtRu019foCkFfdvFlB78n6YsOyu0SKB/P8/4+4H/8BpHbxOEkudK9AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"ZipFS\"\n        title=\"\"\n        src=\"/my-blog/static/1db220041cd22c8624b08248b4b48699/fcda8/zip.png\"\n        srcset=\"/my-blog/static/1db220041cd22c8624b08248b4b48699/12f09/zip.png 148w,\n/my-blog/static/1db220041cd22c8624b08248b4b48699/e4a3f/zip.png 295w,\n/my-blog/static/1db220041cd22c8624b08248b4b48699/fcda8/zip.png 590w,\n/my-blog/static/1db220041cd22c8624b08248b4b48699/efc66/zip.png 885w,\n/my-blog/static/1db220041cd22c8624b08248b4b48699/c83ae/zip.png 1180w,\n/my-blog/static/1db220041cd22c8624b08248b4b48699/78612/zip.png 1260w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol start=\"2\">\n<li>yarn set version berry</li>\n<li>1로 인해 생성된 <code>.yarnrc.yml</code>파일에 다음 내용을 추가한다.<code>nodeLinker: \"pnp\"</code></li>\n<li>yarn</li>\n<li>yarn dlx @yarnpkg/sdks vscode</li>\n</ol>\n<ul>\n<li>IDE에서 TS + PnP를 사용하기위해 필요하다.</li>\n<li><a href=\"https://yarnpkg.com/getting-started/editor-sdks\">공식문서 참고</a></li>\n</ul>\n<ol start=\"6\">\n<li>yarn plugin import typescript</li>\n</ol>\n<ul>\n<li>자체적으로 타입을 포함하지 않는 패키지를 추가할 때 @types/패키지를 자동으로 추가해주는 편리한 플러그인이다.</li>\n</ul>\n<ol start=\"7\">\n<li><code>cmd</code>+<code>shift</code>+<code>p</code> -> Typescript: Select Typescript Version... -> Use Workspace Version 선택</li>\n</ol>\n<h2>만약 lint-staged를 사용할경우 필요한 작업</h2>\n<p>그냥 npx mrm lint-staged로 하면 꽤 간편하게 설정이 됐었지만 아무래도 berry에선 안되는 모양이므로 다음과 같은 방식으로 해결하였다.</p>\n<ol>\n<li>yarn add -D husky</li>\n<li>yarn husky install</li>\n<li>yarn add -D lint-staged</li>\n<li>.husky에 pre-commit파일 생성</li>\n<li>yarn husky add .husky/pre-commit</li>\n<li>pre-commit파일을 열어 다음과 같은 내용을 추가</li>\n</ol>\n<pre><code class=\"language-sh\">#!/usr/bin/env sh\n. \"$(dirname -- \"$0\")/_/husky.sh\"\n\nyarn lint-staged\n</code></pre>\n<h2>실제로 사용해본 결과</h2>\n<p>기존에 tRPC 사용해볼 용도의 간단한 내용의 모노레포 프로젝트가 있었는데 tRPC 버전을 올릴겸 yarn berry를 적용해 보았더니 다음과 같이 개선 되었다.</p>\n<p><code>308MB, 파일 22373개</code> → <code>146MB, 파일776개</code></p>\n<p>용량도 용량이지만 파일 개수가 어마어마하게 줄었다. 가벼운 프로젝트에서도 이 정도의 개선이 이루어질 정도라면 IDE의 파일 인덱싱 부담이 상당히 줄어드는 부수효과도 얻을 수 있을 것으로 보인다.</p>\n<p>주의할 점으로는 패키지가 PnP를 지원하지 않는다거나, 버전을 올려야 하는 경우이다. 버전업의 경우 메이저 버전이 바뀌어야 한다면 꽤 큰 공사가 될 수도 있으니 마냥 좋다고 바꾸기는 어려워 보인다.</p>","frontmatter":{"title":"Yarn Berry PnP구성","date":"March 25, 2023","description":"Yarn Berry의 PnP전략이 나온 이유와 PnP 적용법"}},"previous":{"fields":{"slug":"/workspaces를-통한-모노레포-생성/"},"frontmatter":{"title":"모노레포에 대해"}},"next":null},"pageContext":{"id":"1740aa06-b19f-5093-bf77-6abd30ec6631","previousPostId":"04cc3e6c-2090-5ad8-8d0a-d3e87f772d06","nextPostId":null}},"staticQueryHashes":["2630815655","2841359383"],"slicesMap":{}}