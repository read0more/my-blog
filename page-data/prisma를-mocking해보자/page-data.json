{"componentChunkName":"component---src-templates-blog-post-js","path":"/prisma를-mocking해보자/","result":{"data":{"site":{"siteMetadata":{"title":"read0more's blog"}},"markdownRemark":{"id":"5e9d58ef-ceeb-5998-80be-534a894be82e","excerpt":"들어가기 전에 이 글은 prisma blog의 The Ultimate Guide to Testing with Prisma part1에서 prisma를 mocking 하는 방법에 대해서만 정리한 글이다. 링크의 글은 mock이 무엇인지, 왜 vitest…","html":"<h2>들어가기 전에</h2>\n<p>이 글은 prisma blog의 <a href=\"https://www.prisma.io/blog/testing-series-1-8eRB5p0Y8o\">The Ultimate Guide to Testing with Prisma part1</a>에서 prisma를 mocking 하는 방법에 대해서만 정리한 글이다. 링크의 글은 mock이 무엇인지, 왜 vitest를 선택했는지 등의 내용들이 있으니 한 번쯤 읽어보는 것을 추천한다.</p>\n<h2>prisma를 mocking해야 하는 이유</h2>\n<p>먼저 언급해두자면, mocking하지 않아도 테스트 자체는 돌아가기는 한다. 하지만 다음과 같은 문제점이 있다.</p>\n<ol>\n<li>실제로 DB에 쌓는 작업이 들어가게 되어 테스트 속도가 현저하게 느려진다.</li>\n<li>테스트로 인해 불필요하게 쌓인 row를 제거하는 작업이 필요하다.</li>\n<li>이전 테스트들에서 쌓인 데이터가 이후의 테스트에 영향을 미칠 수 있어 테스트의 독립성이 깨진다.</li>\n</ol>\n<p>셋 다 치명적인 문제점으로 이를 해결하기 위해 prisma의 mocking이 필요하다</p>\n<h2>필요한 package 설치</h2>\n<p>먼저 <code>npm i -D vitest-mock-extended</code>로 vitest-mock-extended를 설치한다. jest환경에서는 <code>jest-mock-extended</code>를 설치하면 되지만 <a href=\"/my-blog/%08node%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-jest%EC%82%AC%EC%9A%A9%EC%9D%84-%ED%94%BC%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0/\">이전 글</a>에서 설명한 이유로 jest환경에서 prisma를 테스트 하는 것은 추천하지 않는다.</p>\n<h2>mocking 방법</h2>\n<p>먼저, prisma-client의 객체를 export하는 모듈을 작성한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">import { PrismaClient } from &#39;@prisma/client&#39;;\n\nconst globalForPrisma = global as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nconst prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    log: [&#39;query&#39;],\n  });\n\nif (process.env.NODE_ENV !== &#39;production&#39;) globalForPrisma.prisma = prisma;\n\nexport default prisma;</code>\n        </deckgo-highlight-code>\n<p>해당 모듈에 <strong>mocks</strong> 디렉토리를 생성하고, 위에서 생성한 모듈과 같은 이름을 가진 파일을 생성하여 다음 예시와 같은 prisma client에 대한 mock을 작성한다. 이 글은 prisma mocking에 대한 내용이므로 자세한 내용은 생략하겠으나, 왜 이렇게 작성하는지에 알고 싶다면 vitest의 <a href=\"https://vitest.dev/guide/mocking.html#automocking-algorithm\">Automocking algorithm</a>을 참고하길 바란다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">import { PrismaClient } from &#39;@prisma/client&#39;;\nimport { beforeEach } from &#39;vitest&#39;;\nimport { mockDeep, mockReset } from &#39;vitest-mock-extended&#39;;\n\nbeforeEach(() =&gt; {\n  mockReset(prisma);\n});\n\nconst prisma = mockDeep&lt;PrismaClient&gt;();\nexport default prisma;</code>\n        </deckgo-highlight-code>\n<h2>테스트</h2>\n<p>User라는 모델이 있고, User의 create에 대해 mocking한다고 가정하면 다음과 같이 mocking할 수 있다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">import prisma from &#39;../__mocks__/prismaClient&#39;; // 위에서 작성한 mock\nvi.mock(&#39;../prismaClient&#39;); // 위에서 작성한 prisma client 객체를 export하는 모듈\n\ntest(&#39;registration should return the generated user without password&#39;, async () =&gt; {\n  prisma.user.create.mockResolvedValue(dummyNewUser); // user create시에 dummyNewUser를 return하게 변경\n});</code>\n        </deckgo-highlight-code>\n<p>이로 인해 해당 테스트 내에서 prisma에서 user를 create 할 때는 무조건 dummyNewUser를 결과로 주게 된다. 또한, mock module에서</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">beforeEach(() =&gt; {\n  mockReset(prisma);\n});</code>\n        </deckgo-highlight-code>\n<p>다음 코드로 각 테스트마다 reset하기 때문에 mock이 리턴하는 값은 각 테스트 별로 독립적임을 보장한다.</p>","frontmatter":{"title":"prisma를 mocking해보자","date":"April 28, 2023","description":"vitest환경에서 prisma를 mocking하여 테스트 하는 방법"}},"previous":{"fields":{"slug":"/\bnode환경에서-jest사용을-피하는-이유/"},"frontmatter":{"title":"node환경에서 jest사용을 피하는 이유"}},"next":{"fields":{"slug":"/Next.js에서-전환추적-스크립트-적용-회고/"},"frontmatter":{"title":"Next.js에서의 전환추적 스크립트 적용 회고"}}},"pageContext":{"id":"5e9d58ef-ceeb-5998-80be-534a894be82e","previousPostId":"c85473f3-a6f7-52f7-8afa-ae20465055f9","nextPostId":"72e7b511-e766-5157-ac94-66f0b31ebe58"}},"staticQueryHashes":["2630815655","2841359383"],"slicesMap":{}}