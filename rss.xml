<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog RSS Feed]]></title><description><![CDATA[사용했던 기술들을 정리하는 일기장 같은 공간입니다.]]></description><link>https://read0more.github.io/blog</link><generator>GatsbyJS</generator><lastBuildDate>Sun, 30 Apr 2023 06:42:01 GMT</lastBuildDate><item><title><![CDATA[prisma를 mocking해보자]]></title><description><![CDATA[들어가기 전에 이 글은 prisma blog의 The Ultimate Guide to Testing with Prisma part1에서 prisma를 mocking 하는 방법에 대해서만 정리한 글이다. 링크의 글은 mock이 무엇인지, 왜 vitest…]]></description><link>https://read0more.github.io/blog/prisma를-mocking해보자/</link><guid isPermaLink="false">https://read0more.github.io/blog/prisma를-mocking해보자/</guid><pubDate>Fri, 28 Apr 2023 12:30:19 GMT</pubDate><content:encoded>&lt;h2&gt;들어가기 전에&lt;/h2&gt;
&lt;p&gt;이 글은 prisma blog의 &lt;a href=&quot;https://www.prisma.io/blog/testing-series-1-8eRB5p0Y8o&quot;&gt;The Ultimate Guide to Testing with Prisma part1&lt;/a&gt;에서 prisma를 mocking 하는 방법에 대해서만 정리한 글이다. 링크의 글은 mock이 무엇인지, 왜 vitest를 선택했는지 등의 내용들이 있으니 한 번쯤 읽어보는 것을 추천한다.&lt;/p&gt;
&lt;h2&gt;prisma를 mocking해야 하는 이유&lt;/h2&gt;
&lt;p&gt;먼저 언급해두자면, mocking하지 않아도 테스트 자체는 돌아가기는 한다. 하지만 다음과 같은 문제점이 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;실제로 DB에 쌓는 작업이 들어가게 되어 테스트 속도가 현저하게 느려진다.&lt;/li&gt;
&lt;li&gt;테스트로 인해 불필요하게 쌓인 row를 제거하는 작업이 필요하다.&lt;/li&gt;
&lt;li&gt;이전 테스트들에서 쌓인 데이터가 이후의 테스트에 영향을 미칠 수 있어 테스트의 독립성이 깨진다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;셋 다 치명적인 문제점으로 이를 해결하기 위해 prisma의 mocking이 필요하다&lt;/p&gt;
&lt;h2&gt;필요한 package 설치&lt;/h2&gt;
&lt;p&gt;먼저 &lt;code&gt;npm i -D vitest-mock-extended&lt;/code&gt;로 vitest-mock-extended를 설치한다. jest환경에서는 &lt;code&gt;jest-mock-extended&lt;/code&gt;를 설치하면 되지만 &lt;a href=&quot;/my-blog/%08node%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-jest%EC%82%AC%EC%9A%A9%EC%9D%84-%ED%94%BC%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0/&quot;&gt;이전 글&lt;/a&gt;에서 설명한 이유로 jest환경에서 prisma를 테스트 하는 것은 추천하지 않는다.&lt;/p&gt;
&lt;h2&gt;mocking 방법&lt;/h2&gt;
&lt;p&gt;먼저, prisma-client의 객체를 export하는 모듈을 작성한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;import { PrismaClient } from &apos;@prisma/client&apos;;

const globalForPrisma = global as unknown as {
  prisma: PrismaClient | undefined;
};

const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: [&apos;query&apos;],
  });

if (process.env.NODE_ENV !== &apos;production&apos;) globalForPrisma.prisma = prisma;

export default prisma;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;해당 모듈에 &lt;strong&gt;mocks&lt;/strong&gt; 디렉토리를 생성하고, 위에서 생성한 모듈과 같은 이름을 가진 파일을 생성하여 다음 예시와 같은 prisma client에 대한 mock을 작성한다. 이 글은 prisma mocking에 대한 내용이므로 자세한 내용은 생략하겠으나, 왜 이렇게 작성하는지에 알고 싶다면 vitest의 &lt;a href=&quot;https://vitest.dev/guide/mocking.html#automocking-algorithm&quot;&gt;Automocking algorithm&lt;/a&gt;을 참고하길 바란다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;import { PrismaClient } from &apos;@prisma/client&apos;;
import { beforeEach } from &apos;vitest&apos;;
import { mockDeep, mockReset } from &apos;vitest-mock-extended&apos;;

beforeEach(() =&gt; {
  mockReset(prisma);
});

const prisma = mockDeep&amp;#x3C;PrismaClient&gt;();
export default prisma;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;테스트&lt;/h2&gt;
&lt;p&gt;User라는 모델이 있고, User의 create에 대해 mocking한다고 가정하면 다음과 같이 mocking할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;import prisma from &apos;../__mocks__/prismaClient&apos;; // 위에서 작성한 mock
vi.mock(&apos;../prismaClient&apos;); // 위에서 작성한 prisma client 객체를 export하는 모듈

test(&apos;registration should return the generated user without password&apos;, async () =&gt; {
  prisma.user.create.mockResolvedValue(dummyNewUser); // user create시에 dummyNewUser를 return하게 변경
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이로 인해 해당 테스트 내에서 prisma에서 user를 create 할 때는 무조건 dummyNewUser를 결과로 주게 된다. 또한, mock module에서&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;beforeEach(() =&gt; {
  mockReset(prisma);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음 코드로 각 테스트마다 reset하기 때문에 mock이 리턴하는 값은 각 테스트 별로 독립적임을 보장한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[node환경에서 jest사용을 피하는 이유]]></title><description><![CDATA[jest의 병렬처리 방식 무엇이 문제인지 알려면 jest의 병렬처리 방식에 대해 알아야 할 필요가 있다. isolated - Tests are parallelized by running them in their own processes to…]]></description><link>https://read0more.github.io/blog/node환경에서-jest사용을-피하는-이유/</link><guid isPermaLink="false">https://read0more.github.io/blog/node환경에서-jest사용을-피하는-이유/</guid><pubDate>Thu, 27 Apr 2023 21:28:19 GMT</pubDate><content:encoded>&lt;h2&gt;jest의 병렬처리 방식&lt;/h2&gt;
&lt;p&gt;무엇이 문제인지 알려면 jest의 병렬처리 방식에 대해 알아야 할 필요가 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;isolated - Tests are parallelized by running them in their own processes to maximize performance.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;위의 문구는 jest의 가이드에 있는 내용으로, 테스트들은 자체 프로세스에서 실행함으로써 병렬처리 한다고 하는 내용이다.&lt;/p&gt;
&lt;p&gt;그렇다면 jest는 이를 어떻게 구현 하였을까? jest는 V8 가상 머신 컨텍스트 내에서 코드를 실행하게 할 수 있는 node:vm module을 이용하여 구현하였다.&lt;/p&gt;
&lt;h2&gt;그래서, 그게 뭐가 문제인데?&lt;/h2&gt;
&lt;p&gt;node:vm은 각자의 컨텍스트를 가졌고, global 객체인 Array, Error와 같은 객체도 가졌다. 그리고 해당 컨텍스트 내에서 Jest는 mock등의 기능을 제공하기 위해 overwrite한다. 그런데, Node.js의 core module에서는 이 overwrite된 객체를 사용 하지않고 기본 구현을 따른다. 이로 인해 객체를 비교할 때 문제가 생긴다.&lt;/p&gt;
&lt;h2&gt;문제 샘플코드&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;const { readFileSync } = require(&apos;fs&apos;);

it(&apos;error가 일치하여 테스트 통과&apos;, () =&gt; {
    try {
      throw new Error(&apos;test&apos;);
    } catch (error) {
      expect(error).toBeInstanceOf(Error)
    }
  })

  it(&apos;error instance가 일치하지 않아 테스트 실패&apos;, () =&gt; {
    try {
      readFileSync(&apos;not-exist&apos;);
    } catch (error) {
      expect(error).toBeInstanceOf(Error)
    }
  })
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위에서 설명했던 문제가 여기서 발생한다. node의 fs core module의 readFileSync를 통해 없는 파일을 읽게 하는 시도를 하게하여 Error를 던지게 하였지만 테스트에서는 두 개의 객체가 같지 않아 에러가 나버린다. 즉, &lt;code&gt;instanceof&lt;/code&gt;의 정상적인 작동을 기대할 수 없다는 뜻이다. 이는 현재 2023/04/27일 기준 최신 버전인 v29.5.0에서도 발생한다.&lt;/p&gt;
&lt;p&gt;이런 이유로 Node.js의 기술 결정 위원회(TSC, Technical Steering Committee)의 멤버인 Matteo Collina도 Node.js 앱에서 jest를 &lt;a href=&quot;https://twitter.com/matteocollina/status/1600058525916360704&quot;&gt;사용하지 않는다&lt;/a&gt;는 트윗을 남긴 적이 있다.&lt;/p&gt;
&lt;h2&gt;대체제&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;vitest&lt;/li&gt;
&lt;li&gt;nodetap&lt;/li&gt;
&lt;li&gt;jest를 유지하고 싶다면 jest-environment-node-single-context, jest-light-runner등의 사용&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;나의 경우는 이미 vitest를 애용하고 있어 1번을 채택한 상황이며 2,3번은 사용해 보지 않았다. 하지만 vitest는 아직 정식버전이 나오지 않았고, 이로 인한 불안으로 jest를 유지하고 싶은 상황도 분명히 많을것으로 보인다. 그럴 때는 2,3번의 대체제가 나을거라고 생각한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[yarn PnP에서의 eslint import rule 관련이슈]]></title><description><![CDATA[발단 프로젝트 스캐폴딩용으로 github에 생성한 템플릿 repo에서 vitest관련 import에서 다음과 같은 에러가 발생했다. 1:1  error  Resolve error: synckit tried to access ", but it isn't…]]></description><link>https://read0more.github.io/blog/yarn-berry에서의-eslint-import-rule-관련이슈/</link><guid isPermaLink="false">https://read0more.github.io/blog/yarn-berry에서의-eslint-import-rule-관련이슈/</guid><pubDate>Sun, 23 Apr 2023 11:10:19 GMT</pubDate><content:encoded>&lt;h1&gt;발단&lt;/h1&gt;
&lt;p&gt;프로젝트 스캐폴딩용으로 github에 생성한 템플릿 repo에서 vitest관련 import에서 다음과 같은 에러가 발생했다.&lt;/p&gt;
&lt;p&gt;1:1  error  Resolve error: synckit tried to access &quot;, but it isn&apos;t declared in its dependencies; this makes the require call ambiguous and unsound.&lt;/p&gt;
&lt;p&gt;Required package: &quot; (via &quot;&quot;/var/folders/1s/2hvl19cn5p1bnb1x26th1m9m0000gn/T/473e5d87de9575172344d889c511233f.cjs&quot;&quot;)
Required by: synckit@npm:0.8.5 (via /Users/yk/Documents/project/my-next-template/.yarn/cache/synckit-npm-0.8.5-40a594eb38-8a9560e5d8.zip/node_modules/synckit/lib/)&lt;/p&gt;
&lt;p&gt;원인이 되는 부분은 해당 import &lt;code&gt;import { defineConfig } from &apos;vitest/config&apos;;&lt;/code&gt; 였다.
vitest/config에서 가져오지 않고 vite에서 가져와도 별 상관은 없지만 어째서 PnP 환경에서만 발생하는지 찾아보았다.&lt;/p&gt;
&lt;h1&gt;원인(예상)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;에러가 난 곳을 보니 synckit이라는 패키지에서 모듈명을 제대로 받지 못하는것으로 보인다.&lt;/li&gt;
&lt;li&gt;거슬러 올라가 보니 해당 synckit은 eslint-import-resolver-typescript에서 사용한다. 여기서 제대로 된 값을 전달하지 못해 에러 문구도 와 같이 빈 문자열에 access하려다 실패한 것으로 보인다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;해결방법&lt;/h1&gt;
&lt;p&gt;위의 예상 원인으로 module resolution이 문제가 아닐까 했고, 해결 방법 자체는 간단하다. eslint 설정 파일에 다음 내용을 추가하면 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;settings: {
    &apos;import/resolver&apos;: &apos;node&apos;,
  },
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;module resolution의 node 방식에 대한 자세한 설명은 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/module-resolution.html#how-nodejs-resolves-modules&quot;&gt;여기&lt;/a&gt;에서 보는 것이 더 빠르다.&lt;/p&gt;
&lt;h1&gt;기타&lt;/h1&gt;
&lt;p&gt;아무래도 tsconfig의 paths를 통한 alias도 해당 설정을 해주면 eslint 에서 오류가 발생하였다. 하지만 어차피 Yarn 2+를 사용하는 이상 link 프로토콜을 쓰는게 여러모로 편하니(alias를 jest, tsconfig, storybook에 전부 따로따로 설정해야 한다던가의 이유로) &lt;del&gt;이 부분은 크게 신경쓰지 않아도 될 것으로 보인다&lt;/del&gt;.&lt;/p&gt;
&lt;p&gt;vitest의 경우 link 프로토콜 사용 시 package.json을 프로젝트 루트에서 찾지 않는다.
예를들어 &lt;code&gt;&quot;src&quot;: &quot;link:./src&quot;&lt;/code&gt;와 같이 했다면 src에서 package.json을 찾으려 시도를 하여 에러가 발생한다. 해결을 위해서 어쩔 수 없이 vitest.config에 alias를 추가해야한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[yarnPnP 환경에서 prisma-client 사용하기]]></title><description><![CDATA[PnP에서 문제가 생기는 부분 prisma-client의 경우 node_module안에 생성을 해주는데, PnP환경에서는 없기 때문에 문제가 된다. 해결 방법 PnP를 지원하지 않는 패키지에 대한 호환성 문제를 해결 하기위해 yarn엔 pnpify…]]></description><link>https://read0more.github.io/blog/yarnPnP에서-prisma-사용하기/</link><guid isPermaLink="false">https://read0more.github.io/blog/yarnPnP에서-prisma-사용하기/</guid><pubDate>Sun, 16 Apr 2023 12:32:19 GMT</pubDate><content:encoded>&lt;h2&gt;PnP에서 문제가 생기는 부분&lt;/h2&gt;
&lt;p&gt;prisma-client의 경우 node_module안에 생성을 해주는데, PnP환경에서는 없기 때문에 문제가 된다.&lt;/p&gt;
&lt;h2&gt;해결 방법&lt;/h2&gt;
&lt;p&gt;PnP를 지원하지 않는 패키지에 대한 호환성 문제를 해결 하기위해 yarn엔 pnpify라는 도구가 존재한다. 이를 통해 해결한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;yarn add @yarnpkg/pnpify&lt;/li&gt;
&lt;li&gt;schema.prisma의 generator client 안에 다음과 같이 client를 출력할 경로를 추가한다.(아래의 예시처럼 한다면 /prisma에 추가됨)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;generator client {
  provider = &quot;prisma-client-js&quot;
  output   = &quot;./&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;prisma-client import 편의성을 위해 package.json에 위에서 추가한 경로를 link로 추가해 준다.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;{
...
	&quot;dependencies&quot;: {
		...
		&quot;prisma-client&quot;: &quot;link:./prisma&quot;,
		...
	}
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;yarn pnpify prisma db push, yarn pnpify prisma generate와 같이 pnpify를 붙여 명령어를 실행한다. studio 실행 시는 따로 안해도 괜찮다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.prisma.io/docs/guides/database/troubleshooting-orm/help-articles/nextjs-prisma-client-monorepo%EB%A5%BC&quot;&gt;https://www.prisma.io/docs/guides/database/troubleshooting-orm/help-articles/nextjs-prisma-client-monorepo를&lt;/a&gt; 참고해서 next.config.js에 webpack관련 설정을 추가한다. monorepo가 아니라도 yarn PnP를 쓸 때 next에서 해당 플러그인을 사용하지 않으면 에러가 발생한다(현재 13.2.4 기준)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;결론&lt;/h2&gt;
&lt;p&gt;PnP가 no install에 디스크 공간도 적게 차지하는 등의 매력적인 환경임에는 틀림 없지만, 이런 문제들로 인해 아직은 실무에서 적용하기에는 적지 않은 비용이 들 것임을 또 한번 느꼈다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Yarn Berry PnP구성]]></title><description><![CDATA[Yarn Berry? yarn V2의 명칭이며 현재 V1은 1.22.19를 마지막으로 관리가 중단된 상태이다.
berry는 npm…]]></description><link>https://read0more.github.io/blog/yarn-berry/</link><guid isPermaLink="false">https://read0more.github.io/blog/yarn-berry/</guid><pubDate>Sat, 25 Mar 2023 19:05:19 GMT</pubDate><content:encoded>&lt;h2&gt;Yarn Berry?&lt;/h2&gt;
&lt;p&gt;yarn V2의 명칭이며 현재 V1은 1.22.19를 마지막으로 관리가 중단된 상태이다.
berry는 npm의 각종 문제점을 개선해준다. &lt;a href=&quot;https://toss.tech/article/node-modules-and-yarn-berry&quot;&gt;토스 기술 블로그&lt;/a&gt;에 굉장히 잘 정리되어 있는데, 본 글은 링크의 글을 보고 알게 된 것을 정리한 글이다.&lt;/p&gt;
&lt;h2&gt;NPM의 문제점&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;비효율적인 의존성 검색&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;파일 시스템을 이용하여 의존성을 관리하는데, 패키지를 찾기 위해 계속 상위 디렉토리의 node_modules 디렉토리를 탐색한다. 따라서 패키지를 늦게 찾을 수록 readdir, stat과 같은 느린 I/O 호출이 반복되고 심지어 경우에 따라서는 실패하기도 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;환경에 따라 달라지는 동작&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;1에서 언급한 대로 NPM은 상위 디렉토리의 node_modules를 찾을 때 까지 검색한다. 이 특성 때문에 어떤 의존성을 찾게 될지는 해당 패키지의 상위 디렉토리 환경에 따라 달라지기 때문에 의존성을 불러오지 못하거나 다른 버전을 불러오게 될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;비효율적인 설치&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;node_modules 디렉토리 구조는 매우 큰 공간을 차지한다. 또한 많은 I/O 호출이 필요해 진다. 이런 깊은 트리 구조에서 잘 설치됐는지 검증하려면 많은 수의 I/O 호출이 필요하기 때문에, Yarn v1과 NPM은 각 패키지의 내용이 올바른지 까지는 확인하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;유령 의존성&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Yarn v1과 NPM은 중복 설치되는 패키지를 줄이기 위해 호이스팅 기법을 사용한다. 여기까지만 들었을때는 그냥 좋다고 생각할 수도 있겠지만&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/my-blog/static/30cb503360fcc1ca5e0cd63c2160d7de/081d5/pd.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 44.5945945945946%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB2ElEQVR42m2STYvTUBSG81PEvX/EvRt3ggjOwpUuBRfOSh3QhQwKgjAoA+IXohudxYAOVgc7A5V0sJM2bZOmzcfNR9vcJDePJG21iC9cLufch3POvffVAIoix45crNjHmUW4SQBlSbm2KiWzCNu3caaC8VQwCBzCioWaUUqhqTynwicfn9J5cIXhww0i/WABqeIPXCpFFYWdJqf3L9O+dwnn9Vadq85WjTWWSg4/YO7cZvR8E9lrrdJkWUZRFKhC1bF0elgv7tLfvUNy8GbZcK1gq9Fn7+URbpAzilMskRLNJH3TJE1ThBBkmVyWL5EZTKZgJTBKVDVefdWVtPfbOtvXvtLXPURk405sojDEMAx836+hyJ/Tbg4YWwFGcMSxtYcvRngTt2aiKMZ1PaSUaO3oC9+CV4i5S3O/x89Ds76mZVnMpvO64Oe3HW5deMen3RaPvYvc6J7lV9xgPPAZOdUAAuO0QygCtCeDq9wcnOPQ2OfRxg+ebX7H9wJ0XcfzPBYuUGSyqPe8lEg1R6mifjOZ5diTkOE4YDgW1acsLFGBJ34DIzhmXSvL/E2s74vAD0KMronnCzRVLh7UTk+43j3D1vA8WS5rtvzHi/9btUOSGLPXI44jfgNdeZ8Jc2u2XQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Phantom Dependency&quot;
        title=&quot;&quot;
        src=&quot;/my-blog/static/30cb503360fcc1ca5e0cd63c2160d7de/fcda8/pd.png&quot;
        srcset=&quot;/my-blog/static/30cb503360fcc1ca5e0cd63c2160d7de/12f09/pd.png 148w,
/my-blog/static/30cb503360fcc1ca5e0cd63c2160d7de/e4a3f/pd.png 295w,
/my-blog/static/30cb503360fcc1ca5e0cd63c2160d7de/fcda8/pd.png 590w,
/my-blog/static/30cb503360fcc1ca5e0cd63c2160d7de/efc66/pd.png 885w,
/my-blog/static/30cb503360fcc1ca5e0cd63c2160d7de/c83ae/pd.png 1180w,
/my-blog/static/30cb503360fcc1ca5e0cd63c2160d7de/081d5/pd.png 1264w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;상기 이미지 처럼 원래 package-1에서 가져올 수 없어야 하는 **B(1.0)**도 가져올 수 있게 되버렸다. 만약 누가 실수로라도 **B(1.0)**을 사용을 했고, 누군가가 B(1.0)패키지를 포함하는 패키지가 더 이상 사용되지 않는다고 생각해서 제거했다면 소리없이 같이 사라져 버릴 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Plug&apos;n&apos;Play(PnP)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;위의 문제들을 해결하기 위해 Yarn Berry는 PnP 전략을 이용하여 해결한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;node_module를 생성하지 않고, &lt;code&gt;.yarn/cache&lt;/code&gt; 디렉토리에 의존성의 정보를 zip파일로 저장하고, &lt;code&gt;.pnp.cjs&lt;/code&gt;파일에 의존성을 찾을 수 있는 정보가 기록된다.
이로 인해 문제가 되던 디스크 I/O 없이 어떤 패키지가 어떤 라이브러리에 의존하고 위치하는지를 바로 알 수 있게 되었다.&lt;/p&gt;
&lt;h2&gt;PnP적용으로 얻는 이점&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;향상된 의존성 검색 시간&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.pnp.cjs&lt;/code&gt;파일을 통해 디스크 I/O 없이 어떤 패키지가 어떤 라이브러리에 의존하고 위치하는지를 바로 알 수 있게 되었기 때문에 빠르다&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;재현성&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.pnp.cjs&lt;/code&gt;로 관리되기 때문에 더 이상 외부 환경에 영향받지 않는다. 이로 인해 require() 또는 import문의 동작이 동일할 것임을 보장할 수 있게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;zero-install로 인한 설치시간 단축&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;깊은 node_modules 디렉토리를 생성하지 않아도 된다. 또한 .yarn/cache에 zip파일로 있는 압축파일을 repo에 올려 같이 관리를 하면 추가 없이 바로 실행이 가능하다. 기존 node_modules와 같이 많은 파일과 용량이 컸다면 사용할 수 없었겠지만 PnP전략으로 인해 zero-install이 가능해 졌다. 기존 방식으로는 브랜치를 바꾸고 의존성 설치를 다시하고...이런 작업이 필요가 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/my-blog/static/a0926f47d1d310e051ce5839073b24c8/a83dd/zi.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 61.48648648648649%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACHElEQVR42lWS2VbbMBCGfduNpRBiS7KsfbFjOyQQKG1Pr6C9aOhN+/6P8vdoCBy4+DyLrF/SzFQuJOjpDnb9HW7zAypfIsaIVipwIcFEC9NZTOMMHxOs85jmNWLM6JSGcwH9sHqJq05bhDRAW48ibn2EdQHaOPgQ4Sn2MGXdB4SQ4HyEOayX/8paEVTaorJKYcoJVhv4EAhtLDqlaEPuexIqpxtjKQ4h0nqI5TBHfs4Z2hhUPkYopbEaR7rJsm5QNw24EOCc46Lh4PESzGRon9H3PZY1w+KixvnFkuxiWeN88eRXUkrITkJphVa2YJwTXHDwVsKYGrvtEXbbY9xeneLL9SlutsdvKPnb7QnZSoYBabqEc5Zu1jB2oIGQGuOK4d/+M/7+PsP+/j0eHz7g8edH/Cn8+oT9/TuK9w/vKa664QpxvUMr+BtB8rmA0hxTv8CQz5DCMXI4IfvMS+wLR6jU6hp5cwPvDIm8puEMstP4Ot9hGGZYn6ijxgZYFwmlHdEwCVYLVKrfoN/cwhqNmjGqX1MovhBopYRWCrLryH9NyZUOl/oXW3KVdAHD7htSimg7hbbrILWCMga8bSkX+xXdtAy6aDui+PowRik9dV92ClV5Wowe2+0G8zxhvZ4xzRP6oadOt9pATzcQrXgapQPlJfWh1i8lYgxV+aScSGg1rogimFKijUJKWKsxTiNSzsTzEBfB5rlEhzL9Bx91UapO6c7kAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Zero Install&quot;
        title=&quot;&quot;
        src=&quot;/my-blog/static/a0926f47d1d310e051ce5839073b24c8/fcda8/zi.png&quot;
        srcset=&quot;/my-blog/static/a0926f47d1d310e051ce5839073b24c8/12f09/zi.png 148w,
/my-blog/static/a0926f47d1d310e051ce5839073b24c8/e4a3f/zi.png 295w,
/my-blog/static/a0926f47d1d310e051ce5839073b24c8/fcda8/zi.png 590w,
/my-blog/static/a0926f47d1d310e051ce5839073b24c8/efc66/zi.png 885w,
/my-blog/static/a0926f47d1d310e051ce5839073b24c8/c83ae/zi.png 1180w,
/my-blog/static/a0926f47d1d310e051ce5839073b24c8/a83dd/zi.png 1482w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;
&lt;em&gt;yarn berry또한 .yarn/cache 디렉토리를 같이 repo에 올려 관리하고 있다.&lt;/em&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;엄격한 의존성 관리&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;node_modules와 같은 호이스팅을 하지 않아 유령 의존성이 일어나지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;의존성 검증&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;node_modules 방식에서는 올바르게 의존성이 설치되지 못해 귀찮게 node_modules 디렉토리 전체를 지우고 다시 설치하는 경우가 발생하곤 했다. 하지만 이제 &lt;code&gt;.yarn/cache에서&lt;/code&gt;zip으로 관리하면서 빠진 의존성을 찾거나 변경된 부분을 찾기가 쉬워졌다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;PnP 적용법(TS + VSCode)&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;VSCode 익스텐션 ZipFs 설치(VSCode가 zip의존성을 읽을 수 있게 해준다)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/my-blog/static/1db220041cd22c8624b08248b4b48699/78612/zip.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 29.72972972972973%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABdElEQVR42nWRvW7TUBiGcwtIrZo45ziOj5O4PnaPU9t1UodgpNDKkEL5mSok/qQuLIyVkKquCAk2boAbQGIuU8XCwMTYuZfQ8UE5SAxIDI/eb3r0vvpa0unQv7VEPz9BVXu4Tpu8KKjrmiRJiOOY6XRKWZZkeU45rSjKCWE4whiDUgopJa7r2mz1bx+Sfbpg8fkn8cdzNrKaelbRLA/YMobtLOfO3j7V7Ca7Zc79Rcn+vMCY1Ep7vR6O4yCEsNKW9/KMZ19+cfb1Byfnlzx8c0rku2wnm6TxJnroM9YjtpIYHYVM0hG5CSmKAq21ZbVklbZhe/6At98u+X51zcXVNR/ev8ObNJhHrwmqJePDY6J7r1CRIYk1wTDEVwOCILAMBn/u1XTbUHYdhovHZMen7Nx9wiBQ6PmS8cELollD2hxhmqekO7vEOrLTpBA2/8U2XFnFxjqdtRu019foCkFfdvFlB78n6YsOyu0SKB/P8/4+4H/8BpHbxOEkudK9AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;ZipFS&quot;
        title=&quot;&quot;
        src=&quot;/my-blog/static/1db220041cd22c8624b08248b4b48699/fcda8/zip.png&quot;
        srcset=&quot;/my-blog/static/1db220041cd22c8624b08248b4b48699/12f09/zip.png 148w,
/my-blog/static/1db220041cd22c8624b08248b4b48699/e4a3f/zip.png 295w,
/my-blog/static/1db220041cd22c8624b08248b4b48699/fcda8/zip.png 590w,
/my-blog/static/1db220041cd22c8624b08248b4b48699/efc66/zip.png 885w,
/my-blog/static/1db220041cd22c8624b08248b4b48699/c83ae/zip.png 1180w,
/my-blog/static/1db220041cd22c8624b08248b4b48699/78612/zip.png 1260w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;yarn set version berry&lt;/li&gt;
&lt;li&gt;1로 인해 생성된 &lt;code&gt;.yarnrc.yml&lt;/code&gt;파일에 다음 내용을 추가한다.&lt;code&gt;nodeLinker: &quot;pnp&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;yarn&lt;/li&gt;
&lt;li&gt;yarn dlx @yarnpkg/sdks vscode&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;IDE에서 TS + PnP를 사용하기위해 필요하다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://yarnpkg.com/getting-started/editor-sdks&quot;&gt;공식문서 참고&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;yarn plugin import typescript&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;자체적으로 타입을 포함하지 않는 패키지를 추가할 때 @types/패키지를 자동으로 추가해주는 편리한 플러그인이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;&lt;code&gt;cmd&lt;/code&gt;+&lt;code&gt;shift&lt;/code&gt;+&lt;code&gt;p&lt;/code&gt; -&gt; Typescript: Select Typescript Version... -&gt; Use Workspace Version 선택&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;만약 lint-staged를 사용할경우 필요한 작업&lt;/h2&gt;
&lt;p&gt;그냥 npx mrm lint-staged로 하면 꽤 간편하게 설정이 됐었지만 아무래도 berry에선 안되는 모양이므로 다음과 같은 방식으로 해결하였다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;yarn add -D husky&lt;/li&gt;
&lt;li&gt;yarn husky install&lt;/li&gt;
&lt;li&gt;yarn add -D lint-staged&lt;/li&gt;
&lt;li&gt;.husky에 pre-commit파일 생성&lt;/li&gt;
&lt;li&gt;yarn husky add .husky/pre-commit&lt;/li&gt;
&lt;li&gt;pre-commit파일을 열어 다음과 같은 내용을 추가&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;#!/usr/bin/env sh
. &quot;$(dirname -- &quot;$0&quot;)/_/husky.sh&quot;

yarn lint-staged
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;실제로 사용해본 결과&lt;/h2&gt;
&lt;p&gt;기존에 tRPC 사용해볼 용도의 간단한 내용의 모노레포 프로젝트가 있었는데 tRPC 버전을 올릴겸 yarn berry를 적용해 보았더니 다음과 같이 개선 되었다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;308MB, 파일 22373개&lt;/code&gt; → &lt;code&gt;146MB, 파일776개&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;용량도 용량이지만 파일 개수가 어마어마하게 줄었다. 가벼운 프로젝트에서도 이 정도의 개선이 이루어질 정도라면 IDE의 파일 인덱싱 부담이 상당히 줄어드는 부수효과도 얻을 수 있을 것으로 보인다.&lt;/p&gt;
&lt;p&gt;주의할 점으로는 패키지가 PnP를 지원하지 않는다거나, 버전을 올려야 하는 경우이다. 버전업의 경우 메이저 버전이 바뀌어야 한다면 꽤 큰 공사가 될 수도 있으니 마냥 좋다고 바꾸기는 어려워 보인다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[모노레포에 대해]]></title><description><![CDATA[모노레포? Monolithic Repositories. 즉 두 개 이상의 프로젝트가 동일한 repository에 구성 된 것을 말한다. 장점 귀찮게 IDE를 스위칭 해가면서 볼 필요가 없다 공통되는 코드 및 설정(prettier, eslint…]]></description><link>https://read0more.github.io/blog/workspaces를-통한-모노레포-생성/</link><guid isPermaLink="false">https://read0more.github.io/blog/workspaces를-통한-모노레포-생성/</guid><pubDate>Sun, 19 Mar 2023 17:32:19 GMT</pubDate><content:encoded>&lt;h2&gt;모노레포?&lt;/h2&gt;
&lt;p&gt;Monolithic Repositories. 즉 두 개 이상의 프로젝트가 동일한 repository에 구성 된 것을 말한다.&lt;/p&gt;
&lt;h2&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;귀찮게 IDE를 스위칭 해가면서 볼 필요가 없다&lt;/li&gt;
&lt;li&gt;공통되는 코드 및 설정(prettier, eslint 같은)의 중복을 없앨 수 있다.&lt;/li&gt;
&lt;li&gt;공통적으로 종속된 패키지도 관리가 편하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;종속성 충돌 문제. 예를 들어 어떤 패키지가 특정 버전의 패키지를 필요로 한다면 다른 버전의 패키지를 사용할 경우 일어나는 충돌을 말한다. 해당 부분에 대한 해결책은 다음 글에서 다루려한다.&lt;/li&gt;
&lt;li&gt;권한적인 문제. 만약 각 패키지가 다른 팀이 담당하고 있다면 설령 다른 팀이라고 할지라도 코드를 수정하고 올릴 수 있다. 이 문제에 대한 처리를 해야 할 것이다.&lt;/li&gt;
&lt;li&gt;패키지중 하나가 문제가 생긴다면 전체적으로 문제가 생긴다.&lt;/li&gt;
&lt;li&gt;파일이 많아지니 속도가 느려진다. IDE, Git, 빌드 시 등...실제로 이러한 문제로 Uber의 경우는 다시 멀티레포로 돌아가기도 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;특정 패키지를 지정할 때&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;npm --w {각 패키지의 package.json의 name 값}
or
yarn workspace {각 패키지의 package.json의 name 값}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;예를들어 server 패키지에 express를 추가하고 싶다면&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm i express --w server
or
yarn workspace server add express
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;package.json 예시&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;{
  &quot;name&quot;: &quot;root&quot;,
  &quot;private&quot;: true,
  &quot;workspaces&quot;: [
    &quot;packages/*&quot;
  ],
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;concurrently \&quot;wsrun --parallel dev\&quot;&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;concurrently&quot;: &quot;^7.6.0&quot;,
    &quot;wsrun&quot;: &quot;^5.2.4&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;workspaces에
concurrently는 여러 명령을 동시에 실행할 때 도움을 주는 패키지이다. monorepo에 관한 글이기 때문에 왜 사용하는지에 대해서는 &lt;a href=&quot;https://github.com/open-cli-tools/concurrently#why&quot;&gt;링크&lt;/a&gt;만 남기고 생략한다.&lt;/p&gt;
&lt;p&gt;wsrun은 각 패키지에 있는 script를 한번에 실행시키려고 추가하였다. 예를 들어 package가 server, client 두 개가 있다면&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;dev&quot;: &quot;concurrently \&quot;yarn workspace server dev\&quot; \&quot;yarn workspace client dev\&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이건&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;dev&quot;: &quot;concurrently \&quot;wsrun --parallel dev\&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이거랑 똑같다.&lt;/p&gt;
&lt;h2&gt;결론&lt;/h2&gt;
&lt;p&gt;Cient와 Backend가 같은 언어로 동작하고, 프로젝트의 사이즈가 너무 크지 않을 때 편할 것으로 보인다. 특히 tRPC를 사용해 보면서 정말 편하다고 느꼈다.
하지만 모노레포를 사용함으로서 초기 설정도 훨씬 수고가 많이 들고 프로젝트가 커지면 커질수록 문제가 발생할 수 있다. 언제나 그렇지만 모든 문제를 한 번에 다 해결해 줄 수 있는 은탄환 따위는 없다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[DOM 요소의 swap]]></title><description><![CDATA[이미 시간이 꽤 지났지만 바닐라JS로 토이프로젝트를 하던 도중 경험한 일이다. 특정 요소 두 개를 swap하고 싶은데... 토이프로젝트를 하던 도중 canvas가 담긴 요소끼리 swap…]]></description><link>https://read0more.github.io/blog/요소의-swap/</link><guid isPermaLink="false">https://read0more.github.io/blog/요소의-swap/</guid><pubDate>Mon, 13 Mar 2023 21:32:19 GMT</pubDate><content:encoded>&lt;p&gt;이미 시간이 꽤 지났지만 바닐라JS로 토이프로젝트를 하던 도중 경험한 일이다.&lt;/p&gt;
&lt;h2&gt;특정 요소 두 개를 swap하고 싶은데...&lt;/h2&gt;
&lt;p&gt;토이프로젝트를 하던 도중 canvas가 담긴 요소끼리 swap 해야 할 일이 생겼고, 어떻게 할까? 생각하던 도중 바로 들었던 생각은&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;아! 그냥 innerHTML이용해서 바꾸면 쉽겠네!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;같은 생각을 하였다. 그래서 처음 엔 다음과 같은 코드를 작성 하였다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function swap(nodeA, nodeB) {
  [nodeA.innerHTML, nodeB.innerHTML] = [nodeB.innerHTML, nodeA.innerHTML];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;하지만 이 방법은 전혀 먹히질 않았고 조사해보다 원인을 알게 되었다. 모던 JavaScript 튜토리얼 사이트(&lt;a href=&quot;https://ko.javascript.info/basic-dom-node-properties#ref-2284)%EC%9D%98&quot;&gt;https://ko.javascript.info/basic-dom-node-properties#ref-2284)의&lt;/a&gt; 내용을 인용하여 이유를 말하자면 이렇다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;기존 내용을 &apos;완전히 삭제’한 후 밑바닥부터 다시 쓰기 때문에 이미지나 리소스 전부가 다시 불러와 집니다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이를 확인하기 위해 간단한 스크립트를 작성해 보았다&lt;/p&gt;
&lt;h2&gt;이미지가 담긴 요소의 swap&lt;/h2&gt;
&lt;p&gt;사실, 단순히 img태그에서 이미지를 불러오게 하는 방식으로는 크게 차이가 없어보였다. 이는 알아서 이미지가 캐싱되었기 때문으로, 크롬 개발자 도구에서 캐싱을 잠시 끄고 테스트 해보았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./swap1.gif&quot; alt=&quot;img swap&quot;&gt;&lt;/p&gt;
&lt;p&gt;처음 2번의 swap은 insertBefore를 이용한 swap이고, 그 다음은 innerHTML을 통한 swap이다. 개발자도구나 화면을 보면 알 수 있듯이 innerHTML로 swap 했을 경우 캐싱을 안했다면 이미지를 다시 불러오는 것을 확인 할 수 있다.&lt;/p&gt;
&lt;h2&gt;canvas가 담긴 요소의 swap&lt;/h2&gt;
&lt;p&gt;이번에는 문제가 더욱 심각하다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./swap2.gif&quot; alt=&quot;img swap2&quot;&gt;&lt;/p&gt;
&lt;p&gt;마찬가지로 처음 2번의 swap은 insertBefore를 이용한 swap이고, 그 다음은 innerHTML을 통한 swap이다.
화면을 보면 알 수 있듯이 innerHTML로 swap을 했더니 canvas로 그린 내용이 사라져 버린다! 위에서 언급했던대로 기존 내용을 &apos;완전히 삭제&apos;한 후 밑바닥부터 다시 쓰기 때문에 이런 현상이 발생한 것이다.&lt;/p&gt;
&lt;h2&gt;결론&lt;/h2&gt;
&lt;p&gt;innerHTML을 통해 바로 swap 하는건 편해보이지만 이러한 이유 및 XSS 취약한 등의 이유로 피하는 편이 좋다. 비록 지금은 웹페이지는 React로만 작성하고 있지만 기본을 아는것이 중요하다고 생각하기에 다시 정리해보았다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[서비스워커 사용해보기]]></title><description><![CDATA[서비스워커 등록 코드 및 동작 확인 위한 img태그 삽입 코드 서비스워커 코드 처음으로 서비스 워커가 있는 페이지에 들어와 설치 및 활성화 된 모습  새로고침 하여 dog.svg에 대한 요청을 가로채 캐시에 있던 cat.svg를 받은 모습  fetch…]]></description><link>https://read0more.github.io/blog/서비스워커-사용해보기/</link><guid isPermaLink="false">https://read0more.github.io/blog/서비스워커-사용해보기/</guid><pubDate>Sat, 11 Mar 2023 17:32:19 GMT</pubDate><content:encoded>&lt;h2&gt;서비스워커 등록 코드 및 동작 확인 위한 img태그 삽입 코드&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;navigator.serviceWorker
    .register(&quot;/sw.js&quot;)
    .then((reg) =&gt; console.log(&quot;서비스워커 등록됨&quot;, reg))
    .catch((err) =&gt; console.log(&quot;서비스워커 등록실패&quot;, err));

  // 이미지 캐싱 확인을 위한 코드
  setTimeout(() =&gt; {
    const img = new Image();
    img.src = &quot;/dog.svg&quot;;
    img.style=&quot;width: 100px; height: 100px;&quot;;
    document.body.appendChild(img);
  }, 1000);

  // 요청을 가로채고 응답하는 것을 보기 위한 fetch
  fetch(&quot;http://localhost:3000/api&quot;)
    .then((res) =&gt; res.json())
    .then((data) =&gt; console.log(data));
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;서비스워커 코드&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;const image = &quot;/cat.svg&quot;;

self.addEventListener(&quot;install&quot;, (event) =&gt; {
  console.log(&quot;V1 installing…&quot;);

  // cat.svg를 캐싱
  event.waitUntil(
    caches.open(&quot;static-v1&quot;).then((cache) =&gt; cache.add(image))
  );
});

self.addEventListener(&quot;activate&quot;, (event) =&gt; {
  console.log(&quot;V1 now ready to handle fetches!&quot;);
});

self.addEventListener(&quot;fetch&quot;, (event) =&gt; {
  const url = new URL(event.request.url);

  // 같은 origin이고 dog.svg를 요청했다면 캐시에 있는 이미지(cat.svg)를 넘겨준다
  if (url.origin == location.origin &amp;#x26;&amp;#x26; url.pathname == &quot;/dog.svg&quot;) {
    event.respondWith(caches.match(image));
  }

  // 현재 서버에 저런 경로가 없던간에 CORS문제가 있는 경로던 간에 서비스워커가 가로채면 상관없다
  if (url.pathname === &apos;/api&apos;) {
    event.respondWith(new Response(JSON.stringify({ data: &apos;CORS가 났더라도 가로채기 때문에 상관없음&apos; })));
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;처음으로 서비스 워커가 있는 페이지에 들어와 설치 및 활성화 된 모습&lt;/h2&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/my-blog/static/d22013767114e4fde593d39dccbc58d2/3fe45/dog.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 60.810810810810814%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACG0lEQVR42qVR7W4SQRTdF2mB/f6c3Znd5cNiAWuJJg0aE620tbGwFqVNaqpC4lP4APyqvAoPwB8egacAjrlDaYq/TNzk5N659+yZc+cq8/kc0+kUo9EI9K1Wq/+C0mq1wDnHeDyWgovF4r4JrPBvwGPBu7vfmEwmmM1mUnC5XK6JRFguAMJqSY11fIz72pbDXz8H+Db4iG7nAtmHc2Tna3y66CLLviDLPqPT7aHb7a1j53LrnHUvcXt9jZt+H1+vrqBUay/BeQweCSRximJagmAh7NIBvLe3cN/cIGoPEBx/R/FsCP91H/xkiOj9D4TtIbxWD67HEPgMvs+g1BvPIeIiwihex1Ag4gl0w4TleNAMGyKtwGcCIqHI5ZnxFKEogsclcJ7Kf1goSPAZGo0DhCGHqurQNANqQZPC1ad17FVrSNIyTNOGZTmwbVdGhy7TdORyBeTz6gOUw8MmTk/P0G6foF5voFQqQ4gEhmHBcXxYtgvH9WE7HmzbkzXKqaYbFgqqLo1soFQqewiCEIWChp2dnCRQTo5ohIBF4CKFqhqyv7ubl6Cc3BF3y+H+fh0pLUIkYCySJLqJmpTrugnHDRAlVRkN04ZpOtIhjUw8Et1AKZef4OjoFd4dt1Gt1h4ENwTKaUERjxEnZfm2AS0mTmG7DPm/HdKbNZsvUKs15BhU3AhSLh16Phzfl0Is5PCDUMJjKTTdkkvcvOEfG+kHgmP3NRoAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;dog&quot;
        title=&quot;&quot;
        src=&quot;/my-blog/static/d22013767114e4fde593d39dccbc58d2/fcda8/dog.png&quot;
        srcset=&quot;/my-blog/static/d22013767114e4fde593d39dccbc58d2/12f09/dog.png 148w,
/my-blog/static/d22013767114e4fde593d39dccbc58d2/e4a3f/dog.png 295w,
/my-blog/static/d22013767114e4fde593d39dccbc58d2/fcda8/dog.png 590w,
/my-blog/static/d22013767114e4fde593d39dccbc58d2/3fe45/dog.png 699w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;새로고침 하여 dog.svg에 대한 요청을 가로채 캐시에 있던 cat.svg를 받은 모습&lt;/h2&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/my-blog/static/d2cee9d911c1a3ae10e1d7d0ba6e4030/416ee/cat.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 74.32432432432432%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAACtElEQVR42q2S2U4aYRTHR30Fo2iHWdiGTRaZEXBANqPSNDZVMYClxjsfoW1SvWtasaAUC+2VkbfwFWriA3jjXtQYNZoYA8m/mWPlpjXxopP8cr7zn7PNd4bZ2vqJnZ0d3N3dodlsotFooKHZR2j+i0ajBfP23XssfFjA/3qY2o9VLBc/Y/njJxTzSyjk81gulPCl+JUorJRRoHOJ9JWVEqrlMiqlEr6vreHb6ioKS0so5vNkGVkOwOFwwO3ywOXsg6OvH/bkLGxjs5BGchDCEzDHpuF8Pgdrcg4W9QVskg1WyQ6RF6FnOXB6HmwvC54TwMTDUcj+EJSBIAbVCKLROEYTEcQTowgPxRAMqggEVURjwwiFIggEQ/AHVCI4OHTv+1XIyn0+43Z7YTCaIUk2mEwSPB4fvF4ZLpcXPt8AZNkPr9f3x8qELA/A4+mHogRIdzpdZLVcxmyWwHECDAYTBMEAvZ5Ht64XLKsnTafrRVeXDj09z8hqPGjd3T3Eg6admaAaoQ52uxNWq4O6ZmdykGUFPC9gYjKF6ekMUqk0JidTGB9/hZcvH2MCTDQWwaAaht1uB8dxSKczuLm5wcbGBhiGQa1Ww+XlJXZ3d3F0dITDw0Pi4OAA+/v72Nvbo3ea1XxmbGwY8eERKIoCSZKQy73B2dkZJbEsS3/A+fk5aVqR4+Nj1Ot18i8uLqj57e0trq+vKY5xub20EJvNAUEQkc2+piRtqvX1dZoykUggFotBFEX6ElmWSZuamsL8/DwWFxdRqVSwubkJxmSy0FJE0UiXmslkcXp6SuNfXV0hmUxS0afQ0dEBxmKx0naNRjNtKpOZwcnJCbG9vY3Ozs5WcFtbG9He3k5o2gOaToW1gjwvtgqm01nU679oumq1SkFa8lOn/KugNqFWULvDcrlMQa3uT+A3FemK8ChVDiwAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;cat&quot;
        title=&quot;&quot;
        src=&quot;/my-blog/static/d2cee9d911c1a3ae10e1d7d0ba6e4030/fcda8/cat.png&quot;
        srcset=&quot;/my-blog/static/d2cee9d911c1a3ae10e1d7d0ba6e4030/12f09/cat.png 148w,
/my-blog/static/d2cee9d911c1a3ae10e1d7d0ba6e4030/e4a3f/cat.png 295w,
/my-blog/static/d2cee9d911c1a3ae10e1d7d0ba6e4030/fcda8/cat.png 590w,
/my-blog/static/d2cee9d911c1a3ae10e1d7d0ba6e4030/efc66/cat.png 885w,
/my-blog/static/d2cee9d911c1a3ae10e1d7d0ba6e4030/416ee/cat.png 930w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;fetch 프록시 확인&lt;/h2&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 540px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/my-blog/static/b9f00e3e9d757efec9ff1666d8343d0e/07484/fetch.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 31.08108108108108%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABKElEQVR42o2OzU7CQBRGeQlNTKSd6XQ6pC1YaJkCBfkrFRMFEhf+rJWVPgBPfwxFVibGxcl3b/Ldk9uYlg+kWU7U7hLFCfEx2wntTo+bJMXaIZPJHKMNgdYoqShGt0zGM2yWM5suyXq2diRJSiPrdZkXOUXWJdaC0HMIlUPku0RhhC1mJHZAXlVkszn9xZJ8WWKrisH6nulmiy1XOE0XKRWN7O2L+PWAeTnQfPzkYvXOZbXnar1HmA7S00jf4OoAoY9pcP2g3uvZtBBBCyk8xFGYb57p7j4Q0yea4x3NYsv1aIsz3uGZGOEIhPDqg1+4R+QJqU4fLoYRd2XJYjKisCmhL2riwMNX/kn2U/6Lc6/RSy39fEQYtZGeQvkaT2l0YFBK/1t4/vAbb023NVVMeRIAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;fetch&quot;
        title=&quot;&quot;
        src=&quot;/my-blog/static/b9f00e3e9d757efec9ff1666d8343d0e/07484/fetch.png&quot;
        srcset=&quot;/my-blog/static/b9f00e3e9d757efec9ff1666d8343d0e/12f09/fetch.png 148w,
/my-blog/static/b9f00e3e9d757efec9ff1666d8343d0e/e4a3f/fetch.png 295w,
/my-blog/static/b9f00e3e9d757efec9ff1666d8343d0e/07484/fetch.png 540w&quot;
        sizes=&quot;(max-width: 540px) 100vw, 540px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[서비스워커에 대하여]]></title><description><![CDATA[서비스 워커? 최근 테스트를 작성하면서 MSW(Mock Service Worker)를 이용하고 있는데, MSW가 서비스 워커를 이용하여 작성된 라이브러리이기 때문에 관심이 생겨서 알아보게 되었다. MDN…]]></description><link>https://read0more.github.io/blog/서비스워커에-대하여/</link><guid isPermaLink="false">https://read0more.github.io/blog/서비스워커에-대하여/</guid><pubDate>Sat, 11 Mar 2023 16:32:19 GMT</pubDate><content:encoded>&lt;h2&gt;서비스 워커?&lt;/h2&gt;
&lt;p&gt;최근 테스트를 작성하면서 MSW(Mock Service Worker)를 이용하고 있는데, MSW가 서비스 워커를 이용하여 작성된 라이브러리이기 때문에 관심이 생겨서 알아보게 되었다.&lt;/p&gt;
&lt;p&gt;MDN의 서비스 워커 설명을 빌리자면 이렇다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;서비스 워커는 웹 응용 프로그램, 브라우저, 그리고 (사용 가능한 경우) 네트워크 사이의 프록시 서버 역할을 합니다. 서비스 워커의 개발 의도는 여러가지가 있지만, 그 중에서도 효과적인 오프라인 경험을 생성하고, 네트워크 요청을 가로채서 네트워크 사용 가능 여부에 따라 적절한 행동을 취하고, 서버의 자산을 업데이트할 수 있습니다. 또한 푸시 알림과 백그라운드 동기화 API로의 접근도 제공합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;중요한 포인트는 다음과 같다고 생각한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;백그라운드에서 실행됨&lt;/li&gt;
&lt;li&gt;프록시 서버 역할을 한다&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;백그라운드에서 실행에 대한 부분만 부가 설명을 하자면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메인 JS와는 다른 스레드에서 동작하므로 서비스 워커의 작업이 메인 스레드의 JS 작업을 방해하지 않는다(논 블로킹). 하지만 DOM과 Web Storage에 접근 할 수는 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;서비스 워커의 생명주기&lt;/h2&gt;
&lt;p&gt;서비스 워커를 작성할 때 필수적으로 알아야 하는 부분이라고 할 수 있다. 생명주기는 다음과 같다.&lt;/p&gt;
&lt;h4&gt;1. 서비스 워커가 제어하는 사이트에 처음 접근하는 순간 다운로드&lt;/h4&gt;
&lt;h4&gt;2. 서비스 워커 설치&lt;/h4&gt;
&lt;h4&gt;3. 서비스 워커 활성화&lt;/h4&gt;
&lt;p&gt;기억해 둘 것은 처음 들어와서 활성화가 됐다고 하더라도 이미 브라우저가 응답을 받은 상태이기 때문에 서비스 워커에 작성한 동작은 다시 방문해야 확인이 가능할 것이다.&lt;/p&gt;
&lt;h2&gt;서비스 워커의 업데이트 특징&lt;/h2&gt;
&lt;h3&gt;1. 기존 서비스 워커 파일과의 &lt;strong&gt;바이트 단위 비교&lt;/strong&gt;로 구분하여 업데이트 한다.&lt;/h3&gt;
&lt;p&gt;이게 뭐가 좋냐하면...그동안 실무를 하면서 js,css파일에 대한 수정사항을 즉각 반영하려 이전 캐싱을 무효화 하기 위해 다음과 같이 사용하는 경우를 자주 볼 수 있었다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;#x3C;script src=&quot;/js/some.js?ver=1.0.0&quot;&gt;&amp;#x3C;/script&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;더 최악은 아예 querystring에 timestamp를 넣어서 아예 캐싱을 막아버리는 경우도 자주 보았다.&lt;/p&gt;
&lt;p&gt;하지만 서비스 워커는 이전 파일에서 변경점이 있는지 알아서 구분해주기 때문에 이런 귀찮은 작업을 할 필요가 없는것이다.&lt;/p&gt;
&lt;h3&gt;2. 업데이트할 서비스 워커파일에 에러가 나면 업데이트 하지 않는다&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;에러가 났다면 chrome 개발자 도구 기준으로 Application-Service Workers에서 확인 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/my-blog/static/d0c60fb59bd09d1527a9779a6b3499d5/d0cc0/sw.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 91.21621621621621%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC30lEQVR42m1U7ZLaOBD0S9ymNiz425YlS7LkD/DCsrBwJLeXZJNU3v9VOjUD5tjU/ega12hozUy3CPp+hca1qHUDpQyM9cgLASEq5EUJ3w7QuoEx7nxuHLRpUGvLtXSmjUNdWzjXIdhud3h9/YKm8cjzEnlecGxcB9/2cL5HUVbIsuJyfkaS5AjD+IooSjgG6/UGX7+94fTpM5bLEW3XQ0oFVRvuwloPYxqUQkIIxV1KpfmSOE6RJNk7BObSLrEvFhEn4ySDEBJSatjGo1IWeZIjChOuWSxCrifCPxFsNlvsdi/Yvxx5N1RIpNMY9K10i8EvUVU1yrLi7vOsQBRNpMl/hM61+Pb2A5//+Ze7mkimcdK0QG0MumHkfZIQtFtlWsRxxvW3YMLD8QRrHWaz+ZWMDimWpYTShtdSVYovpVhJiywrkaZ0aX5F4JzHfn/A4fA3F08jT6qRokRGYpzJarZVkqTIspzVv0WgtcXj+gnPz3tWdCKk7opCsLq0M3exEflSKc01f5Ix4Tiu4Xx3tsaNFShSV5WsuSu2UW1YOFEpFEIizQse+Z3KZOiXlyOOx08Yxw3fMh3SNxmYRiUxjHUQhUAkKsxOB9w/jiwMqRxd9h70/RJdN/A4rPKlw0k18h2J0PUrHpe6o1w4j5DHMfI0RRjeqEzFh8OJO6SXQkmyyuR86jTPBRPR+GT2LC+RUa4sGVR/3aG1Dd6+/8SPn7/Qtv11VHrwtmkZ9JoI8ipGyTXpBe9EoTF92+Hp6Rm73QHDMLI4fthifH7FsD5B1Q2krPkt33ru/xAoLqz4B6vVGqtxc/6L0g2876/PjcA+FOpsbIJQEKVk89NldB7UjUc7PML3K5imhe+XcN2AxneorYPUFrK2EEqjJAvVhiOB8ta1aPsllLaojUOwjmLsRYVtKbBahFjOFxijGMMixDBfoH+Yo5s9oJ09wN1/5O/hJqfuPkDff4T86w7y7gN+AyrLGWJhe9jxAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;개발자 도구에서의 Service Worker확인&quot;
        title=&quot;&quot;
        src=&quot;/my-blog/static/d0c60fb59bd09d1527a9779a6b3499d5/fcda8/sw.png&quot;
        srcset=&quot;/my-blog/static/d0c60fb59bd09d1527a9779a6b3499d5/12f09/sw.png 148w,
/my-blog/static/d0c60fb59bd09d1527a9779a6b3499d5/e4a3f/sw.png 295w,
/my-blog/static/d0c60fb59bd09d1527a9779a6b3499d5/fcda8/sw.png 590w,
/my-blog/static/d0c60fb59bd09d1527a9779a6b3499d5/d0cc0/sw.png 732w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3. 설치된 새 서비스 워커의 활성화 조건&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;이전 서비스 워커가 제어하는 클라이언트(탭)이 없을 때 활성화 된다. 즉 모든 탭을 닫고 다시 들어가야 한다.&lt;/li&gt;
&lt;li&gt;탭이 하나만 있고, 해당 페이지를 새로고침한다고 활성화 되지 않는다.
&lt;ul&gt;
&lt;li&gt;self.skipWating을 통해 활성화를 빠르게 할 수 있지만 좋은 생각은 아니다. 아직 이전 서비스 워커가 작업중인 무언가가 있는데 강제로 활성화 한다면? 굉장히 찾기 힘든 버그를 유발할 수도 있다.&lt;/li&gt;
&lt;li&gt;물론 개발자가 동작을 확인 할 때는 이런 부분이 오히려 불편한 부분이기 때문에 그럴 땐 개발자 도구에서 skipWating을 클릭하여 강제로 활성화 해주면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/my-blog/static/06fa9fcbe6b0222d164c57870170d55b/914ae/sw2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 58.10810810810811%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB3klEQVR42nVT7W7bMAz0awwDYsvWh/VhW7LiOlvcZUG7rmiWZdj7v8sNZBsvHbAfBCWaPh7JU+F9j65PCCHChx5KaShtENOW4/0wInSR7+SHYeRY10f2MWaOkSes4vn5Bd53aFsLpQwnTXefsJ1mWBdgjGVvbYBpHcpSoKrq1fheijVenM8X7PcLUhoRAgE7OBcQwsBgTaO4UCM1n+ta/teEkCgIQIgGm81rBSk1tLHouggbRk6iOOUIUUO8nSuy6/mGcXE6nfH4+J2rX38mo4p9ysjbGS706GNm1ptSYPNvyytwg+LldObW6MMr7YZNKoM0JuTdHsdpwq9xwNO84Og7zLJGrVpIHke7siRfnH78xHS3ewdIlZihDzC+x2fb4qlVmLuEe+fx1UhI46CV4UVZ6zmfW16WA5bly9rytZrWLcugtR6udZhbg1xXyI2ApuU0ihnSf8OQ2BOpgi4h9OuWCFBryzKhmaW0RcoT/JAhGo2q0bxx+WYEFOOIlDLfi8PhCGJJWrzOj3XnArOjdqggScm4AGnsu1nzvKVmuRH4Ckgt3iYRfXo522nHYifxftzN+HC/R6U0RFmv0rnddnG5/MbDwzcG/Ks3ShTMcoiZnyDPmBZX1usCbglc7Q9zcGJVRxU6gAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;개발자 도구에서의 Service Worker확인2(skipWating)&quot;
        title=&quot;&quot;
        src=&quot;/my-blog/static/06fa9fcbe6b0222d164c57870170d55b/fcda8/sw2.png&quot;
        srcset=&quot;/my-blog/static/06fa9fcbe6b0222d164c57870170d55b/12f09/sw2.png 148w,
/my-blog/static/06fa9fcbe6b0222d164c57870170d55b/e4a3f/sw2.png 295w,
/my-blog/static/06fa9fcbe6b0222d164c57870170d55b/fcda8/sw2.png 590w,
/my-blog/static/06fa9fcbe6b0222d164c57870170d55b/914ae/sw2.png 860w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;다음은 실제로 코드를 작성하여 짧게 사용해보려 한다 &lt;a href=&quot;/my-blog/%EC%84%9C%EB%B9%84%EC%8A%A4%EC%9B%8C%EC%BB%A4-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0&quot;&gt;서비스워커 사용해보기&lt;/a&gt;.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[짧은 vitest 사용후기]]></title><description><![CDATA[Vitest? 공식 사이트의 말을 빌리자면... Vite-native unit test framework 짧게 써보고 느낀점 1. 설정이 편하다 Vite-native라는 말을 쓴 것 답게 vite config파일 안에 설정한 alias…]]></description><link>https://read0more.github.io/blog/짧은-vitest-사용후기/</link><guid isPermaLink="false">https://read0more.github.io/blog/짧은-vitest-사용후기/</guid><pubDate>Sun, 26 Feb 2023 10:32:19 GMT</pubDate><content:encoded>&lt;h2&gt;Vitest?&lt;/h2&gt;
&lt;p&gt;공식 사이트의 말을 빌리자면...&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vite-native unit test framework&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;짧게 써보고 느낀점&lt;/h2&gt;
&lt;h3&gt;1. 설정이 편하다&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Vite-native라는 말을 쓴 것 답게 vite config파일 안에 설정한 alias도 그대로 사용 가능했다.(내 기억이 맞다면 jest의 경우는 따로 또 지정해야 해서 다소 귀찮았다.)&lt;/li&gt;
&lt;li&gt;vite config 파일이 공유되는걸 제외 하더라도, 설정이 jest보다 할게 적고 편하게 느껴졌다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2. 빠르다&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;정확한 벤치마킹을 해보진 않았지만 watch모드의 경우 체감이 될 정도로 jest보다 빨랐다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;사용한 설정 파일(vite.config.ts)&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;/// &amp;#x3C;reference types=&quot;vitest&quot; /&gt;
import { defineConfig } from &apos;vite&apos;;
import react from &apos;@vitejs/plugin-react&apos;;

// https://vitejs.dev/config/
export default defineConfig({
  test: {
    globals: true,
    environment: &apos;jsdom&apos;,
    setupFiles: &apos;./setupTests.ts&apos;,
    include: [&apos;**/__tests__/*.{ts,tsx}&apos;],
  },
  plugins: [react()],
  resolve: {
    alias: {
      &apos;@&apos;: &apos;/src&apos;,
    },
  },
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 설정 파일에서 test property가 vitest에 대해 설정한 전부다.&lt;/p&gt;
&lt;h2&gt;VSC 익스텐션을 사용한 모습&lt;/h2&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/my-blog/static/b6d625e953f884553e55314bc6233fea/3dde1/vsc.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 32.43243243243243%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABGElEQVR42oXM0U6DMACFYd5D2jEolEJZS+ks2xhGExf1/d/nN5KpiTdefDk55+Jkc5o5ny+klEhpJsa4ORw8qlF412O7Fm16zODpekvXDwx2YPKOg3PotqXRGlXXZG4cua4ry3IlhAmtW+pGY5qGqdcsR881RtbjkckFomlJumGsKnxZMpYlYb8nFAXDriCrW006zazrE4+PaTt1zlNWitcQeHeOVbe89B0vXcezMax1zakomKVkUiXnaAm9IvQ1mbeW2+3G29sHl8tCCJFxnNCtQeY58uEB8ce25zk7IRAiR+53iJ3cZKMPnE4L8Ziw1mGMZRg8zo0IKf+3nf7KqkpRltVGqfrHV5dSIoVAiu+8+97vh1u/+wRtj7EeV7vuJgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;VSC vitest extension&quot;
        title=&quot;&quot;
        src=&quot;/my-blog/static/b6d625e953f884553e55314bc6233fea/fcda8/vsc.png&quot;
        srcset=&quot;/my-blog/static/b6d625e953f884553e55314bc6233fea/12f09/vsc.png 148w,
/my-blog/static/b6d625e953f884553e55314bc6233fea/e4a3f/vsc.png 295w,
/my-blog/static/b6d625e953f884553e55314bc6233fea/fcda8/vsc.png 590w,
/my-blog/static/b6d625e953f884553e55314bc6233fea/efc66/vsc.png 885w,
/my-blog/static/b6d625e953f884553e55314bc6233fea/3dde1/vsc.png 1018w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;결론&lt;/h2&gt;
&lt;p&gt;react 프로젝트를 시작할 때 vite를 애용하고 있는데, 앞으로는 vitest도 같이 애용하게 될 것 같다. 또한 공식 사이트의 말을 다시 한 번 더 빌리자면&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vitest aims to position itself as the Test Runner of choice for Vite projects, and as a solid alternative even for projects not using Vite.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;즉, vite를 사용하지 않는 프로젝트에서도 대안으로 자리잡는 것을 목표로 하고 있다고 한다. 사용해보니 제법 맘에 들었기 때문에 다음엔 Next.js에서도 vitest를 사용하는 쪽으로 가보려고 한다.&lt;/p&gt;</content:encoded></item></channel></rss>