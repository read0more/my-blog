<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog RSS Feed]]></title><description><![CDATA[사용했던 기술들을 정리하고, 새로운 기술들을 공부하고, 공부한 내용을 정리하는 공간입니다.]]></description><link>https://read0more.github.io/blog</link><generator>GatsbyJS</generator><lastBuildDate>Mon, 13 Mar 2023 12:59:10 GMT</lastBuildDate><item><title><![CDATA[DOM 요소의 swap]]></title><description><![CDATA[이미 시간이 꽤 지났지만 바닐라JS로 토이프로젝트를 하던 도중 경험한 일이다. 특정 요소 두 개를 swap하고 싶은데... 토이프로젝트를 하던 도중 canvas가 담긴 요소끼리 swap…]]></description><link>https://read0more.github.io/blog/요소의-swap/</link><guid isPermaLink="false">https://read0more.github.io/blog/요소의-swap/</guid><pubDate>Mon, 13 Mar 2023 21:32:19 GMT</pubDate><content:encoded>&lt;p&gt;이미 시간이 꽤 지났지만 바닐라JS로 토이프로젝트를 하던 도중 경험한 일이다.&lt;/p&gt;
&lt;h2&gt;특정 요소 두 개를 swap하고 싶은데...&lt;/h2&gt;
&lt;p&gt;토이프로젝트를 하던 도중 canvas가 담긴 요소끼리 swap 해야 할 일이 생겼고, 어떻게 할까? 생각하던 도중 바로 들었던 생각은&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;아! 그냥 innerHTML이용해서 바꾸면 쉽겠네!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;같은 생각을 하였다. 그래서 처음 엔 다음과 같은 코드를 작성 하였다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function swap(nodeA, nodeB) {
  [nodeA.innerHTML, nodeB.innerHTML] = [nodeB.innerHTML, nodeA.innerHTML];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;하지만 이 방법은 전혀 먹히질 않았고 조사해보다 원인을 알게 되었다. 모던 JavaScript 튜토리얼 사이트(&lt;a href=&quot;https://ko.javascript.info/basic-dom-node-properties#ref-2284)%EC%9D%98&quot;&gt;https://ko.javascript.info/basic-dom-node-properties#ref-2284)의&lt;/a&gt; 내용을 인용하여 이유를 말하자면 이렇다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;기존 내용을 &apos;완전히 삭제’한 후 밑바닥부터 다시 쓰기 때문에 이미지나 리소스 전부가 다시 불러와 집니다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이를 확인하기 위해 간단한 스크립트를 작성해 보았다&lt;/p&gt;
&lt;h2&gt;이미지가 담긴 요소의 swap&lt;/h2&gt;
&lt;p&gt;사실, 단순히 img태그에서 이미지를 불러오게 하는 방식으로는 크게 차이가 없어보였다. 이는 알아서 이미지가 캐싱되었기 때문으로, 크롬 개발자 도구에서 캐싱을 잠시 끄고 테스트 해보았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/my-blog/6657acc2e3237366bcca2bbb89932ae1/swap1.gif&quot; alt=&quot;img swap&quot;&gt;&lt;/p&gt;
&lt;p&gt;처음 2번의 swap은 insertBefore를 이용한 swap이고, 그 다음은 innerHTML을 통한 swap이다. 개발자도구나 화면을 보면 알 수 있듯이 innerHTML로 swap 했을 경우 캐싱을 안했다면 이미지를 다시 불러오는 것을 확인 할 수 있다.&lt;/p&gt;
&lt;h2&gt;canvas가 담긴 요소의 swap&lt;/h2&gt;
&lt;p&gt;이번에는 문제가 더욱 심각하다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/my-blog/7d2d6c03f9599a5897f3c5a30f5b21b7/swap2.gif&quot; alt=&quot;img swap2&quot;&gt;&lt;/p&gt;
&lt;p&gt;마찬가지로 처음 2번의 swap은 insertBefore를 이용한 swap이고, 그 다음은 innerHTML을 통한 swap이다.
화면을 보면 알 수 있듯이 innerHTML로 swap을 했더니 canvas로 그린 내용이 사라져 버린다! 위에서 언급했던대로 기존 내용을 &apos;완전히 삭제&apos;한 후 밑바닥부터 다시 쓰기 때문에 이런 현상이 발생한 것이다.&lt;/p&gt;
&lt;h2&gt;결론&lt;/h2&gt;
&lt;p&gt;innerHTML을 통해 바로 swap 하는건 편해보이지만 이러한 이유 및 XSS 취약한 등의 이유로 피하는 편이 좋다. 비록 지금은 웹페이지는 React로만 작성하고 있지만 기본을 아는것이 중요하다고 생각하기에 다시 정리해보았다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[서비스워커 사용해보기]]></title><description><![CDATA[서비스워커 등록 코드 및 동작 확인 위한 img태그 삽입 코드 서비스워커 코드 처음으로 서비스 워커가 있는 페이지에 들어와 설치 및 활성화 된 모습 dog 새로고침 하여 dog.svg에 대한 요청을 가로채 캐시에 있던 cat.svg를 받은 모습 cat…]]></description><link>https://read0more.github.io/blog/서비스워커-사용해보기/</link><guid isPermaLink="false">https://read0more.github.io/blog/서비스워커-사용해보기/</guid><pubDate>Sat, 11 Mar 2023 17:32:19 GMT</pubDate><content:encoded>&lt;h2&gt;서비스워커 등록 코드 및 동작 확인 위한 img태그 삽입 코드&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;navigator.serviceWorker
    .register(&quot;/sw.js&quot;)
    .then((reg) =&gt; console.log(&quot;서비스워커 등록됨&quot;, reg))
    .catch((err) =&gt; console.log(&quot;서비스워커 등록실패&quot;, err));

  // 이미지 캐싱 확인을 위한 코드
  setTimeout(() =&gt; {
    const img = new Image();
    img.src = &quot;/dog.svg&quot;;
    img.style=&quot;width: 100px; height: 100px;&quot;;
    document.body.appendChild(img);
  }, 1000);

  // 요청을 가로채고 응답하는 것을 보기 위한 fetch
  fetch(&quot;http://localhost:3000/api&quot;)
    .then((res) =&gt; res.json())
    .then((data) =&gt; console.log(data));
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;서비스워커 코드&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;const image = &quot;/cat.svg&quot;;

self.addEventListener(&quot;install&quot;, (event) =&gt; {
  console.log(&quot;V1 installing…&quot;);

  // cat.svg를 캐싱
  event.waitUntil(
    caches.open(&quot;static-v1&quot;).then((cache) =&gt; cache.add(image))
  );
});

self.addEventListener(&quot;activate&quot;, (event) =&gt; {
  console.log(&quot;V1 now ready to handle fetches!&quot;);
});

self.addEventListener(&quot;fetch&quot;, (event) =&gt; {
  const url = new URL(event.request.url);

  // 같은 origin이고 dog.svg를 요청했다면 캐시에 있는 이미지(cat.svg)를 넘겨준다
  if (url.origin == location.origin &amp;#x26;&amp;#x26; url.pathname == &quot;/dog.svg&quot;) {
    event.respondWith(caches.match(image));
  }

  // 현재 서버에 저런 경로가 없던간에 CORS문제가 있는 경로던 간에 서비스워커가 가로채면 상관없다
  if (url.pathname === &apos;/api&apos;) {
    event.respondWith(new Response(JSON.stringify({ data: &apos;CORS가 났더라도 가로채기 때문에 상관없음&apos; })));
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;처음으로 서비스 워커가 있는 페이지에 들어와 설치 및 활성화 된 모습&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./dog.png&quot; alt=&quot;dog&quot;&gt;&lt;/p&gt;
&lt;h2&gt;새로고침 하여 dog.svg에 대한 요청을 가로채 캐시에 있던 cat.svg를 받은 모습&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./cat.png&quot; alt=&quot;cat&quot;&gt;&lt;/p&gt;
&lt;h2&gt;fetch 프록시 확인&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./fetch.png&quot; alt=&quot;fetch&quot;&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[서비스워커에 대하여]]></title><description><![CDATA[서비스 워커? 최근 테스트를 작성하면서 MSW(Mock Service Worker)를 이용하고 있는데, MSW가 서비스 워커를 이용하여 작성된 라이브러리이기 때문에 관심이 생겨서 알아보게 되었다. MDN…]]></description><link>https://read0more.github.io/blog/서비스워커에-대하여/</link><guid isPermaLink="false">https://read0more.github.io/blog/서비스워커에-대하여/</guid><pubDate>Sat, 11 Mar 2023 16:32:19 GMT</pubDate><content:encoded>&lt;h2&gt;서비스 워커?&lt;/h2&gt;
&lt;p&gt;최근 테스트를 작성하면서 MSW(Mock Service Worker)를 이용하고 있는데, MSW가 서비스 워커를 이용하여 작성된 라이브러리이기 때문에 관심이 생겨서 알아보게 되었다.&lt;/p&gt;
&lt;p&gt;MDN의 서비스 워커 설명을 빌리자면 이렇다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;서비스 워커는 웹 응용 프로그램, 브라우저, 그리고 (사용 가능한 경우) 네트워크 사이의 프록시 서버 역할을 합니다. 서비스 워커의 개발 의도는 여러가지가 있지만, 그 중에서도 효과적인 오프라인 경험을 생성하고, 네트워크 요청을 가로채서 네트워크 사용 가능 여부에 따라 적절한 행동을 취하고, 서버의 자산을 업데이트할 수 있습니다. 또한 푸시 알림과 백그라운드 동기화 API로의 접근도 제공합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;중요한 포인트는 다음과 같다고 생각한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;백그라운드에서 실행됨&lt;/li&gt;
&lt;li&gt;프록시 서버 역할을 한다&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;백그라운드에서 실행에 대한 부분만 부가 설명을 하자면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메인 JS와는 다른 스레드에서 동작하므로 서비스 워커의 작업이 메인 스레드의 JS 작업을 방해하지 않는다(논 블로킹). 하지만 DOM과 Web Storage에 접근 할 수는 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;서비스 워커의 생명주기&lt;/h2&gt;
&lt;p&gt;서비스 워커를 작성할 때 필수적으로 알아야 하는 부분이라고 할 수 있다. 생명주기는 다음과 같다.&lt;/p&gt;
&lt;h4&gt;1. 서비스 워커가 제어하는 사이트에 처음 접근하는 순간 다운로드&lt;/h4&gt;
&lt;h4&gt;2. 서비스 워커 설치&lt;/h4&gt;
&lt;h4&gt;3. 서비스 워커 활성화&lt;/h4&gt;
&lt;p&gt;기억해 둘 것은 처음 들어와서 활성화가 됐다고 하더라도 이미 브라우저가 응답을 받은 상태이기 때문에 서비스 워커에 작성한 동작은 다시 방문해야 확인이 가능할 것이다.&lt;/p&gt;
&lt;h2&gt;서비스 워커의 업데이트 특징&lt;/h2&gt;
&lt;h3&gt;1. 기존 서비스 워커 파일과의 &lt;strong&gt;바이트 단위 비교&lt;/strong&gt;로 구분하여 업데이트 한다.&lt;/h3&gt;
&lt;p&gt;이게 뭐가 좋냐하면...그동안 실무를 하면서 js,css파일에 대한 수정사항을 즉각 반영하려 이전 캐싱을 무효화 하기 위해 다음과 같이 사용하는 경우를 자주 볼 수 있었다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;#x3C;script src=&quot;/js/some.js?ver=1.0.0&quot;&gt;&amp;#x3C;/script&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;더 최악은 아예 querystring에 timestamp를 넣어서 아예 캐싱을 막아버리는 경우도 자주 보았다.&lt;/p&gt;
&lt;p&gt;하지만 서비스 워커는 이전 파일에서 변경점이 있는지 알아서 구분해주기 때문에 이런 귀찮은 작업을 할 필요가 없는것이다.&lt;/p&gt;
&lt;h3&gt;2. 업데이트할 서비스 워커파일에 에러가 나면 업데이트 하지 않는다&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;에러가 났다면 chrome 개발자 도구 기준으로 Application-Service Workers에서 확인 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./sw.png&quot; alt=&quot;개발자 도구에서의 Service Worker확인&quot;&gt;&lt;/p&gt;
&lt;h3&gt;3. 설치된 새 서비스 워커의 활성화 조건&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;이전 서비스 워커가 제어하는 클라이언트(탭)이 없을 때 활성화 된다. 즉 모든 탭을 닫고 다시 들어가야 한다.&lt;/li&gt;
&lt;li&gt;탭이 하나만 있고, 해당 페이지를 새로고침한다고 활성화 되지 않는다.
&lt;ul&gt;
&lt;li&gt;self.skipWating을 통해 활성화를 빠르게 할 수 있지만 좋은 생각은 아니다. 아직 이전 서비스 워커가 작업중인 무언가가 있는데 강제로 활성화 한다면? 굉장히 찾기 힘든 버그를 유발할 수도 있다.&lt;/li&gt;
&lt;li&gt;물론 개발자가 동작을 확인 할 때는 이런 부분이 오히려 불편한 부분이기 때문에 그럴 땐 개발자 도구에서 skipWating을 클릭하여 강제로 활성화 해주면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./sw2.png&quot; alt=&quot;개발자 도구에서의 Service Worker확인2(skipWating)&quot;&gt;&lt;/p&gt;
&lt;p&gt;다음은 실제로 코드를 작성하여 짧게 사용해보려 한다 &lt;a href=&quot;/my-blog/%EC%84%9C%EB%B9%84%EC%8A%A4%EC%9B%8C%EC%BB%A4-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0&quot;&gt;서비스워커 사용해보기&lt;/a&gt;.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[짧은 vitest 사용후기]]></title><description><![CDATA[Vitest? 공식 사이트의 말을 빌리자면... Vite-native unit test framework 짧게 써보고 느낀점 1. 설정이 편하다 Vite-native라는 말을 쓴 것 답게 vite config파일 안에 설정한 alias…]]></description><link>https://read0more.github.io/blog/짧은-vitest-사용후기/</link><guid isPermaLink="false">https://read0more.github.io/blog/짧은-vitest-사용후기/</guid><pubDate>Sun, 26 Feb 2023 10:32:19 GMT</pubDate><content:encoded>&lt;h2&gt;Vitest?&lt;/h2&gt;
&lt;p&gt;공식 사이트의 말을 빌리자면...&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vite-native unit test framework&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;짧게 써보고 느낀점&lt;/h2&gt;
&lt;h3&gt;1. 설정이 편하다&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Vite-native라는 말을 쓴 것 답게 vite config파일 안에 설정한 alias도 그대로 사용 가능했다.(내 기억이 맞다면 jest의 경우는 따로 또 지정해야 해서 다소 귀찮았다.)&lt;/li&gt;
&lt;li&gt;vite config 파일이 공유되는걸 제외 하더라도, 설정이 jest보다 할게 적고 편하게 느껴졌다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2. 빠르다&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;정확한 벤치마킹을 해보진 않았지만 watch모드의 경우 체감이 될 정도로 jest보다 빨랐다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;사용한 설정 파일(vite.config.ts)&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;/// &amp;#x3C;reference types=&quot;vitest&quot; /&gt;
import { defineConfig } from &apos;vite&apos;;
import react from &apos;@vitejs/plugin-react&apos;;

// https://vitejs.dev/config/
export default defineConfig({
  test: {
    globals: true,
    environment: &apos;jsdom&apos;,
    setupFiles: &apos;./setupTests.ts&apos;,
    include: [&apos;**/__tests__/*.{ts,tsx}&apos;],
  },
  plugins: [react()],
  resolve: {
    alias: {
      &apos;@&apos;: &apos;/src&apos;,
    },
  },
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 설정 파일에서 test property가 vitest에 대해 설정한 전부다.&lt;/p&gt;
&lt;h2&gt;VSC 익스텐션을 사용한 모습&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./vsc.png&quot; alt=&quot;VSC vitest extension&quot;&gt;&lt;/p&gt;
&lt;h2&gt;결론&lt;/h2&gt;
&lt;p&gt;react 프로젝트를 시작할 때 vite를 애용하고 있는데, 앞으로는 vitest도 같이 애용하게 될 것 같다. 또한 공식 사이트의 말을 다시 한 번 더 빌리자면&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vitest aims to position itself as the Test Runner of choice for Vite projects, and as a solid alternative even for projects not using Vite.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;즉, vite를 사용하지 않는 프로젝트에서도 대안으로 자리잡는 것을 목표로 하고 있다고 한다. 사용해보니 제법 맘에 들었기 때문에 다음엔 Next.js에서도 vitest를 사용하는 쪽으로 가보려고 한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[블로그 시작]]></title><description><![CDATA[…]]></description><link>https://read0more.github.io/blog/블로그-시작/</link><guid isPermaLink="false">https://read0more.github.io/blog/블로그-시작/</guid><pubDate>Sun, 26 Feb 2023 09:32:19 GMT</pubDate><content:encoded>&lt;h2&gt;뭐라도 남겨보자&lt;/h2&gt;
&lt;p&gt;글을 쓰는 것은 언제나 귀찮았고, 해본것들은 검색하면 나올 것들이 대부분인데 굳이 써야하나 싶었다. 하지만 자신이 뭘 했는지 보여줄 필요도 있거니와, 다시 한 번 정리 해보는 시간도 필요하다고 느껴서 일단 뭐라도 남겨보자라는 마음으로 시작하기로 마음 먹었다.&lt;/p&gt;
&lt;h2&gt;뭘로 만들었나&lt;/h2&gt;
&lt;p&gt;gatsby-starter-blog로 만들었고, deploy는 github pages에 하였다.&lt;/p&gt;
&lt;p&gt;Gatsby는 이번에 처음 써봤는데, 따로 문서를 안봐도 블로그 같은 정적 컨텐츠를 다루기에는 문제가 없겠다 싶을 정도로 알기 쉽게 구성되어 있는 것 같아서 만족스럽다.(게다가 커스텀 하기도 좋아 보인다.)&lt;/p&gt;
&lt;h2&gt;결론&lt;/h2&gt;
&lt;p&gt;앞으로 뭔가 해볼 때는 블로그에 남겨보자.&lt;/p&gt;</content:encoded></item></channel></rss>